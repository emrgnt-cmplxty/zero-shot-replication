{"task_id": "LeetCode/2818", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        prefix = [0]*(n+1)\n        dp = [0]*(n+1)\n        dp[0] = 1\n        for i in range(1, n+1):\n            prefix[i] = prefix[i-1] + nums[i-1]\n        for i in range(1, n+1):\n            dp[i] = max(dp[i], dp[i-1]*nums[i-1])\n            for j in range(i):\n                dp[i] = max(dp[i], dp[j]*(prefix[i]-prefix[j]))\n        return dp[n] % mod\n```\n\nThis solution uses dynamic programming to keep track of the maximum score that can be achieved up to each index in the array. The dp array stores the maximum score that can be achieved up to index i. The inner loop iterates over all possible subarrays ending at index i, and for each subarray, it calculates the product of the score up to the start of the subarray and the sum of the subarray. The maximum of these products is then stored in the dp array. The final answer is the value in the dp array corresponding to the last index.", "extracted_code": "\nclass Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        prefix = [0]*(n+1)\n        dp = [0]*(n+1)\n        dp[0] = 1\n        for i in range(1, n+1):\n            prefix[i] = prefix[i-1] + nums[i-1]\n        for i in range(1, n+1):\n            dp[i] = max(dp[i], dp[i-1]*nums[i-1])\n            for j in range(i):\n                dp[i] = max(dp[i], dp[j]*(prefix[i]-prefix[j]))\n        return dp[n] % mod\n", "difficulty": 3.0}
{"task_id": "LeetCode/2813", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nfrom collections import deque\n\nclass Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        n = len(items)\n        items.sort(key=lambda x: x[0], reverse=True)\n        dq = deque()\n        max_elegance = float('-inf')\n        distinct_categories = set()\n        \n        for i in range(n):\n            while dq and dq[0][1] == items[i][1]:\n                dq.popleft()\n            dq.append(items[i])\n            if len(dq) == k:\n                max_elegance = max(max_elegance, sum(x[0] for x in dq) + len(distinct_categories))\n                distinct_categories.add(dq[0][1])\n                dq.popleft()\n        \n        return max_elegance\n```\n\nThis function works by first sorting the items by their profit in descending order. Then, it uses a deque to keep track of the current subsequence of size k. The deque is maintained in such a way that it always contains items with distinct categories. The elegance of the current subsequence is calculated and compared with the maximum elegance found so far. The maximum elegance is updated whenever a new maximum elegance is found. The function returns the maximum elegance found after processing all the items.", "extracted_code": "\nfrom typing import List\nfrom collections import deque\n\nclass Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        n = len(items)\n        items.sort(key=lambda x: x[0], reverse=True)\n        dq = deque()\n        max_elegance = float('-inf')\n        distinct_categories = set()\n        \n        for i in range(n):\n            while dq and dq[0][1] == items[i][1]:\n                dq.popleft()\n            dq.append(items[i])\n            if len(dq) == k:\n                max_elegance = max(max_elegance, sum(x[0] for x in dq) + len(distinct_categories))\n                distinct_categories.add(dq[0][1])\n                dq.popleft()\n        \n        return max_elegance\n", "difficulty": 3.0}
{"task_id": "LeetCode/2809", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:\n        total = sum(nums1)\n        if total <= x:\n            return 0\n        n = len(nums1)\n        l, r = 0, n\n        while l < r:\n            m = (l + r) // 2\n            if sum(max(0, nums1[i] + m - 1) for i in range(n)) <= x:\n                r = m\n            else:\n                l = m + 1\n        return l if sum(max(0, nums1[i] + l - 1) for i in range(n)) <= x else -1\n```", "extracted_code": "\nclass Solution:\n    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:\n        total = sum(nums1)\n        if total <= x:\n            return 0\n        n = len(nums1)\n        l, r = 0, n\n        while l < r:\n            m = (l + r) // 2\n            if sum(max(0, nums1[i] + m - 1) for i in range(n)) <= x:\n                r = m\n            else:\n                l = m + 1\n        return l if sum(max(0, nums1[i] + l - 1) for i in range(n)) <= x else -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2801", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSteppingNumbers(self, low: str, high: str) -> int:\n        mod = 10**9 + 7\n        n = len(low)\n        dp = [[0]*10 for _ in range(n+1)]\n        dp[0][0] = 1\n        for i in range(1, n+1):\n            for j in range(10):\n                for k in range(10):\n                    if abs(k-j) == 1:\n                        dp[i][k] = (dp[i][k] + dp[i-1][j]) % mod\n        ans = 0\n        for i in range(1, 10):\n            ans = (ans + dp[n][i]) % mod\n        low = int(low)\n        high = int(high)\n        for i in range(n+1):\n            if i == n:\n                for j in range(10):\n                    if low <= j <= high:\n                        ans = (ans + 1) % mod\n            else:\n                for j in range(10):\n                    if low <= int(str(j) + '0'*(n-i-1)) <= high:\n                        ans = (ans + dp[i][j]) % mod\n        return ans\n```\n\nThis function uses dynamic programming to count the stepping numbers in the given range. The dp array stores the count of stepping numbers with a certain number of digits, where the number of digits is the index of the outer list, and the last digit is the index of the inner list. The function iterates through all possible last digits and updates the dp array accordingly. After calculating the dp array, the function iterates through all possible numbers in the given range and updates the answer accordingly. The answer is then returned modulo 10^9 + 7.", "extracted_code": "\nclass Solution:\n    def countSteppingNumbers(self, low: str, high: str) -> int:\n        mod = 10**9 + 7\n        n = len(low)\n        dp = [[0]*10 for _ in range(n+1)]\n        dp[0][0] = 1\n        for i in range(1, n+1):\n            for j in range(10):\n                for k in range(10):\n                    if abs(k-j) == 1:\n                        dp[i][k] = (dp[i][k] + dp[i-1][j]) % mod\n        ans = 0\n        for i in range(1, 10):\n            ans = (ans + dp[n][i]) % mod\n        low = int(low)\n        high = int(high)\n        for i in range(n+1):\n            if i == n:\n                for j in range(10):\n                    if low <= j <= high:\n                        ans = (ans + 1) % mod\n            else:\n                for j in range(10):\n                    if low <= int(str(j) + '0'*(n-i-1)) <= high:\n                        ans = (ans + dp[i][j]) % mod\n        return ans\n", "difficulty": 3.0}
{"task_id": "LeetCode/2791", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countPalindromePaths(self, parent: List[int], s: str) -> int:\n        n = len(parent)\n        tree = [[] for _ in range(n)]\n        for i in range(1, n):\n            tree[parent[i]].append(i)\n\n        def dfs(node, path):\n            count = [0] * 26\n            for child in tree[node]:\n                for c in s[child]:\n                    count[ord(c) - ord('a')] += 1\n                count[ord(s[child]) - ord('a')] -= 1\n                if count[ord(s[child]) - ord('a')] == 0:\n                    path.append(s[child])\n                dfs(child, path)\n                path.pop()\n\n        path = []\n        dfs(0, path)\n        return len(path)\n```\n\nThis function uses depth-first search (DFS) to traverse the tree and count the number of palindrome paths. It first constructs an adjacency list representation of the tree. Then, it defines a helper function `dfs` that takes a node and the current path as input. This function iterates over the children of the current node, updates the count of characters in the path, and checks if the current character can be rearranged to form a palindrome. If so, it appends the character to the path and recursively calls `dfs` for the child node. After the recursive call, it removes the last character from the path. Finally, it calls `dfs` for the root node and returns the length of the path, which represents the number of palindrome paths.", "extracted_code": "\nclass Solution:\n    def countPalindromePaths(self, parent: List[int], s: str) -> int:\n        n = len(parent)\n        tree = [[] for _ in range(n)]\n        for i in range(1, n):\n            tree[parent[i]].append(i)\n\n        def dfs(node, path):\n            count = [0] * 26\n            for child in tree[node]:\n                for c in s[child]:\n                    count[ord(c) - ord('a')] += 1\n                count[ord(s[child]) - ord('a')] -= 1\n                if count[ord(s[child]) - ord('a')] == 0:\n                    path.append(s[child])\n                dfs(child, path)\n                path.pop()\n\n        path = []\n        dfs(0, path)\n        return len(path)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2790", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        n = len(usageLimits)\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            dp[i] = 1\n            for j in range(i):\n                if usageLimits[i] <= usageLimits[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n```\n\nThis function uses dynamic programming to solve the problem. The `dp` array stores the maximum number of groups that can be created using the first `i` numbers in `usageLimits`. For each number `i`, it iterates over all previous numbers `j` and checks if the usage limit of `i` is less than or equal to the usage limit of `j`. If so, it updates the maximum number of groups for `i` to be the maximum of the current value and the value for `j` plus one. The final result is the maximum value in the `dp` array.", "extracted_code": "\nclass Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        n = len(usageLimits)\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            dp[i] = 1\n            for j in range(i):\n                if usageLimits[i] <= usageLimits[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2781", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        forbidden_set = set(forbidden)\n        max_length = 0\n        left = 0\n        for right in range(len(word)):\n            current_word = word[left:right+1]\n            if current_word not in forbidden_set:\n                max_length = max(max_length, len(current_word))\n            else:\n                left = right + 1\n        return max_length\n```", "extracted_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        forbidden_set = set(forbidden)\n        max_length = 0\n        left = 0\n        for right in range(len(word)):\n            current_word = word[left:right+1]\n            if current_word not in forbidden_set:\n                max_length = max(max_length, len(current_word))\n            else:\n                left = right + 1\n        return max_length\n", "difficulty": 3.0}
{"task_id": "LeetCode/2763", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        n = len(nums)\n        sorted_nums = sorted(nums)\n        imbalance_sum = 0\n        for i in range(n - 1):\n            if sorted_nums[i + 1] - sorted_nums[i] > 1:\n                imbalance_sum += 1\n        return imbalance_sum\n```", "extracted_code": "\nclass Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        n = len(nums)\n        sorted_nums = sorted(nums)\n        imbalance_sum = 0\n        for i in range(n - 1):\n            if sorted_nums[i + 1] - sorted_nums[i] > 1:\n                imbalance_sum += 1\n        return imbalance_sum\n", "difficulty": 3.0}
{"task_id": "LeetCode/2751", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n        n = len(positions)\n        robots = list(zip(positions, healths, directions))\n        robots.sort()\n        stack = []\n        for pos, health, dir in robots:\n            while stack:\n                if dir == 'R' and stack[-1][0] < pos or dir == 'L' and stack[-1][0] > pos:\n                    break\n                if stack[-1][1] < health:\n                    health -= 1\n                else:\n                    stack.pop()\n                if health <= 0:\n                    break\n            else:\n                stack.append((pos, health))\n        return [health for pos, health in stack]\n```\n\nThis function works by first zipping the positions, healths, and directions into a list of tuples and sorting it based on the position. Then, it iterates over the sorted list and for each robot, it pops robots from the stack that are in the way of the current robot. If the current robot's direction is to the right and the robot on the top of the stack has a smaller position, or if the current robot's direction is to the left and the robot on the top of the stack has a larger position, then the current robot can pass the robot on the top of the stack without colliding. If the current robot's health is greater than the health of the robot on the top of the stack, then the current robot will collide with the robot on the top of the stack and decrease its health by one. If the current robot's health becomes zero or less, then the current robot is removed from the line and the loop breaks. If no robots are in the way of the current robot or the current robot collides with all robots in its way, then the current robot is pushed onto the stack. Finally, the function returns the healths of the robots that survive the collisions in the order they were given in the input.", "extracted_code": "\nclass Solution:\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n        n = len(positions)\n        robots = list(zip(positions, healths, directions))\n        robots.sort()\n        stack = []\n        for pos, health, dir in robots:\n            while stack:\n                if dir == 'R' and stack[-1][0] < pos or dir == 'L' and stack[-1][0] > pos:\n                    break\n                if stack[-1][1] < health:\n                    health -= 1\n                else:\n                    stack.pop()\n                if health <= 0:\n                    break\n            else:\n                stack.append((pos, health))\n        return [health for pos, health in stack]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2742", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        n = len(cost)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            dp[i][i] = min(dp[i - 1][i - 1] + cost[i - 1], dp[i - 1][i - 2] + time[i - 1])\n            for j in range(i - 1, 0, -1):\n                dp[i][j] = min(dp[i - 1][j - 1] + cost[j - 1], dp[i - 1][j] + time[j - 1])\n        return min(dp[n][i] for i in range(n + 1))\n```", "extracted_code": "\nclass Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        n = len(cost)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            dp[i][i] = min(dp[i - 1][i - 1] + cost[i - 1], dp[i - 1][i - 2] + time[i - 1])\n            for j in range(i - 1, 0, -1):\n                dp[i][j] = min(dp[i - 1][j - 1] + cost[j - 1], dp[i - 1][j] + time[j - 1])\n        return min(dp[n][i] for i in range(n + 1))\n", "difficulty": 3.0}
{"task_id": "LeetCode/2736", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums1)\n        nums1.sort()\n        nums2.sort()\n        result = []\n        for x, y in queries:\n            i = j = 0\n            while i < n and nums1[i] >= x:\n                i += 1\n            while j < n and nums2[j] >= y:\n                j += 1\n            if i == 0 or j == 0:\n                result.append(-1)\n            else:\n                result.append(nums1[i-1] + nums2[j-1])\n        return result\n```", "extracted_code": "\nclass Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums1)\n        nums1.sort()\n        nums2.sort()\n        result = []\n        for x, y in queries:\n            i = j = 0\n            while i < n and nums1[i] >= x:\n                i += 1\n            while j < n and nums2[j] >= y:\n                j += 1\n            if i == 0 or j == 0:\n                result.append(-1)\n            else:\n                result.append(nums1[i-1] + nums2[j-1])\n        return result\n", "difficulty": 3.0}
{"task_id": "LeetCode/2732", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\n        m, n = len(grid), len(grid[0])\n        rows = [[sum(grid[i][j] for j in range(n)) for i in range(m) if grid[i][j] == 1] for j in range(n)]\n        rows.sort(key=len)\n        for i in range(len(rows)):\n            if all(row <= (i // 2) for row in rows[i]):\n                return sorted([j for j, row in enumerate(rows[i]) if row])\n        return []\n```", "extracted_code": "\nclass Solution:\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\n        m, n = len(grid), len(grid[0])\n        rows = [[sum(grid[i][j] for j in range(n)) for i in range(m) if grid[i][j] == 1] for j in range(n)]\n        rows.sort(key=len)\n        for i in range(len(rows)):\n            if all(row <= (i // 2) for row in rows[i]):\n                return sorted([j for j, row in enumerate(rows[i]) if row])\n        return []\n", "difficulty": 3.0}
{"task_id": "LeetCode/2719", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        MOD = 10**9 + 7\n        num1, num2 = int(num1), int(num2)\n        min_sum, max_sum = max(min_sum, num1), min(max_sum, num2)\n        return sum(max(0, min(max_sum, num2) - max(min_sum, num1) + 1)) % MOD\n```\n\nThis function works by first converting the input strings to integers. It then adjusts the min_sum and max_sum to be within the range of num1 and num2, respectively. The function then calculates the number of integers between max(min_sum, num1) and min(max_sum, num2) (inclusive) and returns this number modulo 10^9 + 7.", "extracted_code": "\nclass Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        MOD = 10**9 + 7\n        num1, num2 = int(num1), int(num2)\n        min_sum, max_sum = max(min_sum, num1), min(max_sum, num2)\n        return sum(max(0, min(max_sum, num2) - max(min_sum, num1) + 1)) % MOD\n", "difficulty": 3.0}
{"task_id": "LeetCode/2713", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        dp = [[0]*n for _ in range(m)]\n        directions = [(0, 1), (1, 0)]\n        res = 0\n\n        for i in range(m):\n            for j in range(n):\n                for dx, dy in directions:\n                    x, y = i + dx, j + dy\n                    if 0 <= x < m and 0 <= y < n and mat[i][j] < mat[x][y]:\n                        dp[i][j] = max(dp[i][j], 1 + dp[x][y])\n                res = max(res, dp[i][j])\n\n        return res\n```\n\nThis function uses dynamic programming to solve the problem. It iterates over each cell in the matrix, and for each cell, it checks if it can move to any other cell in the same row or column with a value strictly greater than the current cell. If it can, it updates the dynamic programming table with the maximum number of cells that can be visited. The maximum number of cells that can be visited is then the maximum value in the dynamic programming table.", "extracted_code": "\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        dp = [[0]*n for _ in range(m)]\n        directions = [(0, 1), (1, 0)]\n        res = 0\n\n        for i in range(m):\n            for j in range(n):\n                for dx, dy in directions:\n                    x, y = i + dx, j + dy\n                    if 0 <= x < m and 0 <= y < n and mat[i][j] < mat[x][y]:\n                        dp[i][j] = max(dp[i][j], 1 + dp[x][y])\n                res = max(res, dp[i][j])\n\n        return res\n", "difficulty": 3.0}
{"task_id": "LeetCode/2709", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nimport math\n\nclass Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        n = len(nums)\n        for i in range(n):\n            for j in range(i+1, n):\n                if math.gcd(nums[i], nums[j]) <= 1:\n                    return False\n        return True\n```\n\nThis function works by iterating over all pairs of indices in `nums` and checking if the greatest common divisor (gcd) of the numbers at those indices is greater than 1. If there exists a pair where the gcd is not greater than 1, the function returns False, indicating that it's not possible to traverse between all pairs of indices. If no such pair is found, the function returns True.", "extracted_code": "\nfrom typing import List\nimport math\n\nclass Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        n = len(nums)\n        for i in range(n):\n            for j in range(i+1, n):\n                if math.gcd(nums[i], nums[j]) <= 1:\n                    return False\n        return True\n", "difficulty": 3.0}
{"task_id": "LeetCode/2699", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nimport heapq\n\nclass Solution:\n    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n        graph = [[] for _ in range(n)]\n        for u, v, w in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        dist = [float('inf')] * n\n        dist[source] = 0\n        heap = [(0, source)]\n        while heap:\n            d, node = heapq.heappop(heap)\n            if d != dist[node]:\n                continue\n            for neighbor, weight in graph[node]:\n                if weight < 0:\n                    weight = max(1, target - dist[node] - abs(weight))\n                if dist[node] + weight < dist[neighbor]:\n                    dist[neighbor] = dist[node] + weight\n                    heapq.heappush(heap, (dist[neighbor], neighbor))\n        if dist[destination] != target:\n            return []\n        for u, v, w in edges:\n            if w < 0:\n                w = max(1, target - dist[u] - abs(w))\n        return edges\n```\n\nThis function first builds an adjacency list representation of the graph. Then it uses Dijkstra's algorithm to find the shortest distance from the source to all other nodes. If the shortest distance from the source to the destination is not equal to the target, it returns an empty array. Otherwise, it updates the weights of the edges with negative weights and returns the modified edges.", "extracted_code": "\nimport heapq\n\nclass Solution:\n    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n        graph = [[] for _ in range(n)]\n        for u, v, w in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        dist = [float('inf')] * n\n        dist[source] = 0\n        heap = [(0, source)]\n        while heap:\n            d, node = heapq.heappop(heap)\n            if d != dist[node]:\n                continue\n            for neighbor, weight in graph[node]:\n                if weight < 0:\n                    weight = max(1, target - dist[node] - abs(weight))\n                if dist[node] + weight < dist[neighbor]:\n                    dist[neighbor] = dist[node] + weight\n                    heapq.heappush(heap, (dist[neighbor], neighbor))\n        if dist[destination] != target:\n            return []\n        for u, v, w in edges:\n            if w < 0:\n                w = max(1, target - dist[u] - abs(w))\n        return edges\n", "difficulty": 3.0}
{"task_id": "LeetCode/2681", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sumOfPower(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        nums.sort()\n        dp = [0]*(n+1)\n        for i in range(1, n+1):\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i-1]**2)\n        return (dp[-1] - nums[-1]**2 + mod) % mod\n```", "extracted_code": "\nclass Solution:\n    def sumOfPower(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        nums.sort()\n        dp = [0]*(n+1)\n        for i in range(1, n+1):\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i-1]**2)\n        return (dp[-1] - nums[-1]**2 + mod) % mod\n", "difficulty": 3.0}
{"task_id": "LeetCode/2659", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\n        operations = 0\n        while nums:\n            if nums[0] == min(nums):\n                nums.pop(0)\n            else:\n                nums.append(nums.pop(0))\n            operations += 1\n        return operations\n```", "extracted_code": "\nclass Solution:\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\n        operations = 0\n        while nums:\n            if nums[0] == min(nums):\n                nums.pop(0)\n            else:\n                nums.append(nums.pop(0))\n            operations += 1\n        return operations\n", "difficulty": 3.0}
{"task_id": "LeetCode/2646", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            nonlocal min_price\n            min_price[node] = price[node]\n            for child in graph[node]:\n                if child != parent:\n                    dfs(child, node)\n                    min_price[node] = min(min_price[node], min_price[child] + price[node])\n        \n        min_price = [0] * n\n        dfs(0, -1)\n        \n        total_price = 0\n        for start, end in trips:\n            total_price += min_price[start] + min_price[end]\n        \n        return total_price\n```", "extracted_code": "\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            nonlocal min_price\n            min_price[node] = price[node]\n            for child in graph[node]:\n                if child != parent:\n                    dfs(child, node)\n                    min_price[node] = min(min_price[node], min_price[child] + price[node])\n        \n        min_price = [0] * n\n        dfs(0, -1)\n        \n        total_price = 0\n        for start, end in trips:\n            total_price += min_price[start] + min_price[end]\n        \n        return total_price\n", "difficulty": 3.0}
{"task_id": "LeetCode/2663", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def smallestBeautifulString(self, s: str, k: int) -> str:\n        alphabet = 'abcdefghijklmnopqrstuvwxyz'\n        n = len(s)\n        if n == k:\n            return ''\n        for c in alphabet:\n            if c not in s:\n                t = s + c\n                if self.is_beautiful(t, k+1):\n                    return t\n        return ''\n\n    def is_beautiful(self, s: str, k: int) -> bool:\n        n = len(s)\n        if n != k:\n            return False\n        for i in range(n-1):\n            if s[i:] == s[i:][::-1]:\n                return False\n        return True\n```\n\nThis solution works by iterating over all the characters in the alphabet and checking if they can be appended to the given string `s` to create a new string of length `k` that is beautiful. The function `is_beautiful` checks if a given string is beautiful by iterating over all its substrings of length 2 or more and checking if any of them are palindromes. If it finds a palindrome, it returns `False`, otherwise it returns `True`.", "extracted_code": "\nclass Solution:\n    def smallestBeautifulString(self, s: str, k: int) -> str:\n        alphabet = 'abcdefghijklmnopqrstuvwxyz'\n        n = len(s)\n        if n == k:\n            return ''\n        for c in alphabet:\n            if c not in s:\n                t = s + c\n                if self.is_beautiful(t, k+1):\n                    return t\n        return ''\n\n    def is_beautiful(self, s: str, k: int) -> bool:\n        n = len(s)\n        if n != k:\n            return False\n        for i in range(n-1):\n            if s[i:] == s[i:][::-1]:\n                return False\n        return True\n", "difficulty": 3.0}
{"task_id": "LeetCode/2617", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        visited = [[0]*n for _ in range(m)]\n        heap = [(grid[0][0], 0, 0)]\n        visited[0][0] = 1\n        res = 0\n        \n        while heap:\n            cells, i, j = heapq.heappop(heap)\n            res += 1\n            for k in range(j+1, min(n, j+grid[i][j]+2)):\n                if not visited[i][k]:\n                    visited[i][k] = 1\n                    heapq.heappush(heap, (cells-k+grid[i][k], i, k))\n            for k in range(i+1, min(m, i+grid[i][j]+2)):\n                if not visited[k][j]:\n                    visited[k][j] = 1\n                    heapq.heappush(heap, (cells-i+grid[k][j], k, j))\n        \n        return res if visited[m-1][n-1] else -1\n```\n\nThis solution uses a priority queue to store the cells to visit next, ordered by the number of cells visited so far (cells) and the current position (i, j). It starts at the top-left cell (0, 0) and explores the grid in a breadth-first manner, visiting the cells that can be reached in one step from the current cell. It keeps track of the visited cells using a separate matrix to avoid visiting the same cell multiple times. If it reaches the bottom-right cell (m-1, n-1), it returns the number of cells visited; otherwise, it returns -1.", "extracted_code": "\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        visited = [[0]*n for _ in range(m)]\n        heap = [(grid[0][0], 0, 0)]\n        visited[0][0] = 1\n        res = 0\n        \n        while heap:\n            cells, i, j = heapq.heappop(heap)\n            res += 1\n            for k in range(j+1, min(n, j+grid[i][j]+2)):\n                if not visited[i][k]:\n                    visited[i][k] = 1\n                    heapq.heappush(heap, (cells-k+grid[i][k], i, k))\n            for k in range(i+1, min(m, i+grid[i][j]+2)):\n                if not visited[k][j]:\n                    visited[k][j] = 1\n                    heapq.heappush(heap, (cells-i+grid[k][j], k, j))\n        \n        return res if visited[m-1][n-1] else -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2612", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\n        ans = [0] * n\n        banned = set(banned)\n        left, right = p, p\n        for i in range(1, k):\n            if left - i >= 0 and left - i not in banned:\n                ans[left - i] = i\n            if right + i < n and right + i not in banned:\n                ans[right + i] = i\n        return ans\n```\n\nThis function works by iterating from 1 to k and checking if the positions to the left and right of the initial position can be reached in i reverse operations, where i ranges from 1 to k. If a position can be reached in i reverse operations, it sets ans[i] to i. If a position is in the banned list, it skips that position. The function returns the ans list, which represents the minimum number of reverse operations needed to bring the 1 to each position.", "extracted_code": "\nclass Solution:\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\n        ans = [0] * n\n        banned = set(banned)\n        left, right = p, p\n        for i in range(1, k):\n            if left - i >= 0 and left - i not in banned:\n                ans[left - i] = i\n            if right + i < n and right + i not in banned:\n                ans[right + i] = i\n        return ans\n", "difficulty": 3.0}
{"task_id": "LeetCode/2603", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import defaultdict\n\nclass Solution:\n    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            nonlocal steps\n            coin_steps = coins[node]\n            for child in graph[node]:\n                if child != parent:\n                    steps += coin_steps\n                    dfs(child, node)\n        \n        start = coins.index(1)\n        steps = 0\n        dfs(start, None)\n        return steps\n```\n\nThis solution uses a depth-first search (DFS) to traverse the tree and count the number of coins that can be collected by moving at most two edges away from the starting node. The DFS function `dfs` is called with the starting node and its parent set to `None`. Inside the `dfs` function, for each child node of the current node, if the child node is not the parent node, the number of coins at the current node is added to the `steps` counter, and the `dfs` function is called recursively for the child node with the current node as the parent. The final value of `steps` is returned as the result.", "extracted_code": "\nfrom collections import defaultdict\n\nclass Solution:\n    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            nonlocal steps\n            coin_steps = coins[node]\n            for child in graph[node]:\n                if child != parent:\n                    steps += coin_steps\n                    dfs(child, node)\n        \n        start = coins.index(1)\n        steps = 0\n        dfs(start, None)\n        return steps\n", "difficulty": 3.0}
{"task_id": "LeetCode/2577", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def minimumTime(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        heap = [(grid[0][0], 0, 0)]\n        visited = [[False]*n for _ in range(m)]\n        visited[0][0] = True\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        while heap:\n            time, x, y = heapq.heappop(heap)\n            if x == m-1 and y == n-1:\n                return time\n            \n            for dx, dy in dirs:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and time + 1 >= grid[nx][ny]:\n                    heapq.heappush(heap, (time + 1, nx, ny))\n                    visited[nx][ny] = True\n        \n        return -1\n```", "extracted_code": "\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def minimumTime(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        heap = [(grid[0][0], 0, 0)]\n        visited = [[False]*n for _ in range(m)]\n        visited[0][0] = True\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        while heap:\n            time, x, y = heapq.heappop(heap)\n            if x == m-1 and y == n-1:\n                return time\n            \n            for dx, dy in dirs:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and time + 1 >= grid[nx][ny]:\n                    heapq.heappush(heap, (time + 1, nx, ny))\n                    visited[nx][ny] = True\n        \n        return -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2573", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        n = len(lcp)\n        word = \"\"\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] == n - 1:\n                    word = chr(ord('a') + i) * n\n                    break\n            if word:\n                break\n        return word\n```", "extracted_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        n = len(lcp)\n        word = \"\"\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] == n - 1:\n                    word = chr(ord('a') + i) * n\n                    break\n            if word:\n                break\n        return word\n", "difficulty": 3.0}
{"task_id": "LeetCode/2569", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        res = []\n        for query in queries:\n            if query[0] == 1:\n                l, r = query[1], query[2]\n                nums1[l:r+1] = [1-i for i in nums1[l:r+1]]\n            elif query[0] == 2:\n                p = query[1]\n                nums2 = [i+i*p for i in nums1]\n            elif query[0] == 3:\n                res.append(sum(nums2))\n        return res\n```", "extracted_code": "\nclass Solution:\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        res = []\n        for query in queries:\n            if query[0] == 1:\n                l, r = query[1], query[2]\n                nums1[l:r+1] = [1-i for i in nums1[l:r+1]]\n            elif query[0] == 2:\n                p = query[1]\n                nums2 = [i+i*p for i in nums1]\n            elif query[0] == 3:\n                res.append(sum(nums2))\n        return res\n", "difficulty": 3.0}
{"task_id": "LeetCode/2565", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumScore(self, s: str, t: str) -> int:\n        s = \" \" + s\n        t = \" \" + t\n        m, n = len(s), len(t)\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if s[i] == t[j]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return m + n - 2 * dp[-1][-1]\n```\n\nThis function uses dynamic programming to find the longest common subsequence (LCS) of `s` and `t`. The LCS is a subsequence of both `s` and `t` which is as long as possible. The score is then calculated as `m + n - 2 * len(LCS)`, where `m` and `n` are the lengths of `s` and `t`, respectively. The time complexity is O(m * n), and the space complexity is also O(m * n).", "extracted_code": "\nclass Solution:\n    def minimumScore(self, s: str, t: str) -> int:\n        s = \" \" + s\n        t = \" \" + t\n        m, n = len(s), len(t)\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if s[i] == t[j]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return m + n - 2 * dp[-1][-1]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2561", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\n\nclass Solution:\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\n        basket1.sort()\n        basket2.sort()\n        total_cost = 0\n        i, j = 0, 0\n        while i < len(basket1) and j < len(basket2):\n            if basket1[i] < basket2[j]:\n                total_cost += basket1[i]\n                i += 1\n            elif basket1[i] > basket2[j]:\n                total_cost += basket2[j]\n                j += 1\n            else:\n                total_cost += basket1[i]\n                i += 1\n                j += 1\n        while i < len(basket1):\n            total_cost += basket1[i]\n            i += 1\n        while j < len(basket2):\n            total_cost += basket2[j]\n            j += 1\n        return total_cost if total_cost <= 10**9 else -1\n```\n\nThis function first sorts both the baskets. Then it iterates over both the baskets simultaneously. If the current fruit in `basket1` is cheaper, it adds the cost to `total_cost` and moves the iterator of `basket1`. If the current fruit in `basket2` is cheaper, it adds the cost to `total_cost` and moves the iterator of `basket2`. If the fruits are of equal cost, it adds the cost to `total_cost` and moves both the iterators. After iterating over both the baskets, it adds any remaining fruits in either basket to `total_cost`. Finally, it returns `total_cost` if it is less than or equal to 10**9; otherwise, it returns -1.", "extracted_code": "\nfrom typing import List\n\nclass Solution:\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\n        basket1.sort()\n        basket2.sort()\n        total_cost = 0\n        i, j = 0, 0\n        while i < len(basket1) and j < len(basket2):\n            if basket1[i] < basket2[j]:\n                total_cost += basket1[i]\n                i += 1\n            elif basket1[i] > basket2[j]:\n                total_cost += basket2[j]\n                j += 1\n            else:\n                total_cost += basket1[i]\n                i += 1\n                j += 1\n        while i < len(basket1):\n            total_cost += basket1[i]\n            i += 1\n        while j < len(basket2):\n            total_cost += basket2[j]\n            j += 1\n        return total_cost if total_cost <= 10**9 else -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2552", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    for l in range(k+1, n):\n                        if nums[i] < nums[k] < nums[j] < nums[l]:\n                            count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    for l in range(k+1, n):\n                        if nums[i] < nums[k] < nums[j] < nums[l]:\n                            count += 1\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2642", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nimport heapq\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, n: int, edges: List[List[int]]):\n        self.n = n\n        self.edges = defaultdict(list)\n        self.weights = defaultdict(list)\n        for u, v, w in edges:\n            self.edges[u].append(v)\n            self.weights[(u, v)] = w\n\n    def addEdge(self, edge: List[int]) -> None:\n        u, v, w = edge\n        self.edges[u].append(v)\n        self.weights[(u, v)] = w\n\n    def shortestPath(self, node1: int, node2: int) -> int:\n        queue = [(0, node1, [])]\n        visited = set()\n        while queue:\n            d, node, path = heapq.heappop(queue)\n            if node not in visited:\n                visited.add(node)\n                path = path + [node]\n                if node == node2:\n                    return d\n                for nei in self.edges[node]:\n                    if nei not in visited:\n                        heapq.heappush(queue, (d + self.weights[(node, nei)], nei, path))\n        return -1\n```", "extracted_code": "\nimport heapq\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, n: int, edges: List[List[int]]):\n        self.n = n\n        self.edges = defaultdict(list)\n        self.weights = defaultdict(list)\n        for u, v, w in edges:\n            self.edges[u].append(v)\n            self.weights[(u, v)] = w\n\n    def addEdge(self, edge: List[int]) -> None:\n        u, v, w = edge\n        self.edges[u].append(v)\n        self.weights[(u, v)] = w\n\n    def shortestPath(self, node1: int, node2: int) -> int:\n        queue = [(0, node1, [])]\n        visited = set()\n        while queue:\n            d, node, path = heapq.heappop(queue)\n            if node not in visited:\n                visited.add(node)\n                path = path + [node]\n                if node == node2:\n                    return d\n                for nei in self.edges[node]:\n                    if nei not in visited:\n                        heapq.heappush(queue, (d + self.weights[(node, nei)], nei, path))\n        return -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2608", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        visited = [0] * n\n        min_cycle_len = float('inf')\n        \n        def dfs(node, parent, depth):\n            nonlocal min_cycle_len\n            visited[node] = 1\n            for child in graph[node]:\n                if child == parent:\n                    min_cycle_len = min(min_cycle_len, depth * 2)\n                elif visited[child] == 0:\n                    dfs(child, node, depth + 1)\n        \n        for node in range(n):\n            if visited[node] == 0:\n                dfs(node, -1, 1)\n        \n        return -1 if min_cycle_len == float('inf') else min_cycle_len\n```\n\nThis function uses a depth-first search (DFS) algorithm to find the shortest cycle in the graph. It first constructs an adjacency list representation of the graph. Then, it performs a DFS from each unvisited node. During the DFS, it keeps track of the depth of the current node (the number of edges from the starting node to the current node). When it encounters an edge that leads back to the parent node, it updates the minimum cycle length if the cycle length through this edge is smaller. The cycle length is the product of the depth and 2, because each edge is counted twice (once in each direction). If no cycle is found, it returns -1.", "extracted_code": "\nfrom collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        visited = [0] * n\n        min_cycle_len = float('inf')\n        \n        def dfs(node, parent, depth):\n            nonlocal min_cycle_len\n            visited[node] = 1\n            for child in graph[node]:\n                if child == parent:\n                    min_cycle_len = min(min_cycle_len, depth * 2)\n                elif visited[child] == 0:\n                    dfs(child, node, depth + 1)\n        \n        for node in range(n):\n            if visited[node] == 0:\n                dfs(node, -1, 1)\n        \n        return -1 if min_cycle_len == float('inf') else min_cycle_len\n", "difficulty": 3.0}
{"task_id": "LeetCode/2589", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\n        tasks.sort(key=lambda x: x[1])\n        on_time = end_time = 0\n        for start, end, duration in tasks:\n            if start >= end_time:\n                on_time += duration\n            else:\n                on_time += max(0, duration - (end_time - start))\n            end_time = max(end_time, end)\n        return on_time\n```\n\nThis function works by first sorting the tasks by their end times. Then it iterates over the sorted tasks and turns on the computer when a task starts. If the task finishes before the computer turns off, it adds the duration of the task to the total on time. If the task finishes after the computer turns off, it adds the remaining duration to the total on time. Finally, it updates the end time of the last task. The minimum time the computer should be turned on to complete all tasks is the total on time.", "extracted_code": "\nclass Solution:\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\n        tasks.sort(key=lambda x: x[1])\n        on_time = end_time = 0\n        for start, end, duration in tasks:\n            if start >= end_time:\n                on_time += duration\n            else:\n                on_time += max(0, duration - (end_time - start))\n            end_time = max(end_time, end)\n        return on_time\n", "difficulty": 3.0}
{"task_id": "LeetCode/2585", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\n        MOD = 10**9 + 7\n        dp = [0] * (target + 1)\n        dp[0] = 1\n        for count, marks in types:\n            for t in range(target, marks - 1, -1):\n                dp[t] = (dp[t] + dp[t - marks]) % MOD\n        return dp[target]\n```", "extracted_code": "\nclass Solution:\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\n        MOD = 10**9 + 7\n        dp = [0] * (target + 1)\n        dp[0] = 1\n        for count, marks in types:\n            for t in range(target, marks - 1, -1):\n                dp[t] = (dp[t] + dp[t - marks]) % MOD\n        return dp[target]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2584", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findValidSplit(self, nums: List[int]) -> int:\n        n = len(nums)\n        gcd_product = [0] * n\n        gcd_product[0] = nums[0]\n        for i in range(1, n):\n            gcd_product[i] = math.gcd(gcd_product[i-1], nums[i])\n        for i in range(n-1, 0, -1):\n            if math.gcd(gcd_product[i-1], gcd_product[n-1]) == 1:\n                return i\n        return -1\n```\n\nThis function works by first calculating the gcd of the product of the first i+1 elements and the product of the remaining elements at each index i. Then, it checks each index in reverse order to find the first index where the gcd of the two products is 1, which indicates a valid split. If no such index is found, it returns -1.", "extracted_code": "\nclass Solution:\n    def findValidSplit(self, nums: List[int]) -> int:\n        n = len(nums)\n        gcd_product = [0] * n\n        gcd_product[0] = nums[0]\n        for i in range(1, n):\n            gcd_product[i] = math.gcd(gcd_product[i-1], nums[i])\n        for i in range(n-1, 0, -1):\n            if math.gcd(gcd_product[i-1], gcd_product[n-1]) == 1:\n                return i\n        return -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2581", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import defaultdict\n\nclass Solution:\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\n        n = len(edges) + 1\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        parent_count = [0] * n\n        for u, v in guesses:\n            parent_count[v] += 1\n        queue = [i for i in range(n) if parent_count[i] == 0]\n        depth = [0] * n\n        while queue:\n            node = queue.pop(0)\n            for child in graph[node]:\n                if depth[child] == 0:\n                    depth[child] = depth[node] + 1\n                    if parent_count[child] == k - 1:\n                        queue.append(child)\n        return sum(depth[i] == 0 for i in range(n))\n```\n\nThis function first builds an adjacency list representation of the tree. Then it initializes an array `parent_count` to count the number of guesses for each node, and a queue to store nodes that have no incoming edges. The function then performs a breadth-first search (BFS) from the nodes in the queue, updating the depth of each node and adding their children to the queue if their depth is not yet set. The BFS stops when all nodes have been visited. The function finally returns the number of nodes that have a depth of 0, which are potential roots of the tree.", "extracted_code": "\nfrom collections import defaultdict\n\nclass Solution:\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\n        n = len(edges) + 1\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        parent_count = [0] * n\n        for u, v in guesses:\n            parent_count[v] += 1\n        queue = [i for i in range(n) if parent_count[i] == 0]\n        depth = [0] * n\n        while queue:\n            node = queue.pop(0)\n            for child in graph[node]:\n                if depth[child] == 0:\n                    depth[child] = depth[node] + 1\n                    if parent_count[child] == k - 1:\n                        queue.append(child)\n        return sum(depth[i] == 0 for i in range(n))\n", "difficulty": 3.0}
{"task_id": "LeetCode/2551", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def putMarbles(self, weights: List[int], k: int) -> int:\n        n = len(weights)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + weights[i]\n\n        dp = [[0] * (n + 1) for _ in range(k + 1)]\n        for i in range(1, k + 1):\n            dp[i][i - 1] = prefix_sum[i]\n            for j in range(i - 1, n):\n                dp[i][j + 1] = min(dp[i - 1][j] + prefix_sum[j + 1] - prefix_sum[j], dp[i][j] + prefix_sum[j + 1] - prefix_sum[j - 1])\n\n        return max(dp[k]) - min(dp[k])\n```", "extracted_code": "\nclass Solution:\n    def putMarbles(self, weights: List[int], k: int) -> int:\n        n = len(weights)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + weights[i]\n\n        dp = [[0] * (n + 1) for _ in range(k + 1)]\n        for i in range(1, k + 1):\n            dp[i][i - 1] = prefix_sum[i]\n            for j in range(i - 1, n):\n                dp[i][j + 1] = min(dp[i - 1][j] + prefix_sum[j + 1] - prefix_sum[j], dp[i][j] + prefix_sum[j + 1] - prefix_sum[j - 1])\n\n        return max(dp[k]) - min(dp[k])\n", "difficulty": 3.0}
{"task_id": "LeetCode/2547", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minCost(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        count = [0] * n\n        for i in range(n):\n            count[i] = nums[i] * (count[i-1] if i > 0 else 0) + 1\n        dp = [0] * (n + 1)\n        for i in range(n):\n            dp[i+1] = min(dp[max(0, i-k+1)] + k + count[i], dp[i] + count[i])\n        return dp[n]\n```\n\nThis function works by first calculating the count array, which stores the number of times each number appears consecutively up to the current index. Then, it uses dynamic programming to find the minimum cost of splitting the array. The dp array stores the minimum cost up to each index in the array. For each index, it considers two options: either splitting the array at that index with a cost of k + count[i], or not splitting the array at that index with a cost of count[i]. It then returns the minimum cost of the entire array.", "extracted_code": "\nclass Solution:\n    def minCost(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        count = [0] * n\n        for i in range(n):\n            count[i] = nums[i] * (count[i-1] if i > 0 else 0) + 1\n        dp = [0] * (n + 1)\n        for i in range(n):\n            dp[i+1] = min(dp[max(0, i-k+1)] + k + count[i], dp[i] + count[i])\n        return dp[n]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2543", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isReachable(self, targetX: int, targetY: int) -> bool:\n        if targetX < targetY:\n            targetX, targetY = targetY, targetX\n        while targetY:\n            if targetX < targetY:\n                return False\n            targetX, targetY = targetX - targetY, targetX\n        return targetX == 1\n```\n\nThis function works by iteratively subtracting the smaller value from the larger one. If at any point the smaller value becomes zero and the larger one is not equal to 1, then it is impossible to reach the target point. If the larger value becomes 1, then it is possible to reach the target point.", "extracted_code": "\nclass Solution:\n    def isReachable(self, targetX: int, targetY: int) -> bool:\n        if targetX < targetY:\n            targetX, targetY = targetY, targetX\n        while targetY:\n            if targetX < targetY:\n                return False\n            targetX, targetY = targetX - targetY, targetX\n        return targetX == 1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2538", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            sub_tree_price_sum = price[node]\n            max_child_price_sum = 0\n            min_child_price_sum = 0\n            for child in graph[node]:\n                if child == parent:\n                    continue\n                child_price_sum, child_max_price_sum, child_min_price_sum = dfs(child, node)\n                sub_tree_price_sum += child_price_sum\n                max_child_price_sum = max(max_child_price_sum, child_max_price_sum)\n                min_child_price_sum = min(min_child_price_sum, child_min_price_sum)\n            \n            max_price_sum = max(max_price_sum, sub_tree_price_sum - min_child_price_sum)\n            min_price_sum = min(min_price_sum, sub_tree_price_sum - max_child_price_sum)\n            return sub_tree_price_sum, max_price_sum, min_price_sum\n        \n        max_price_sum = -np.inf\n        min_price_sum = np.inf\n        for i in range(n):\n            _, max_price_sum, min_price_sum = dfs(i, -1)\n        \n        return max_price_sum - min_price_sum\n```", "extracted_code": "\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            sub_tree_price_sum = price[node]\n            max_child_price_sum = 0\n            min_child_price_sum = 0\n            for child in graph[node]:\n                if child == parent:\n                    continue\n                child_price_sum, child_max_price_sum, child_min_price_sum = dfs(child, node)\n                sub_tree_price_sum += child_price_sum\n                max_child_price_sum = max(max_child_price_sum, child_max_price_sum)\n                min_child_price_sum = min(min_child_price_sum, child_min_price_sum)\n            \n            max_price_sum = max(max_price_sum, sub_tree_price_sum - min_child_price_sum)\n            min_price_sum = min(min_price_sum, sub_tree_price_sum - max_child_price_sum)\n            return sub_tree_price_sum, max_price_sum, min_price_sum\n        \n        max_price_sum = -np.inf\n        min_price_sum = np.inf\n        for i in range(n):\n            _, max_price_sum, min_price_sum = dfs(i, -1)\n        \n        return max_price_sum - min_price_sum\n", "difficulty": 3.0}
{"task_id": "LeetCode/2532", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        workers = sorted([(a+b, a, b, i) for i, (a, b, c, d) in enumerate(time)], key=lambda x: (-x[0], x[3]))\n        time_elapsed = 0\n        boxes_left = n\n        while boxes_left > 0:\n            while len(workers) > 0 and workers[0][0] <= time_elapsed:\n                _, left_time, right_time, worker_id = heapq.heappop(workers)\n                time_elapsed += left_time\n                boxes_left -= 1\n                if boxes_left > 0:\n                    heapq.heappush(workers, (time_elapsed + right_time, left_time, right_time, worker_id))\n            time_elapsed += 1\n        return time_elapsed\n```\n\nThis solution uses a priority queue to keep track of the workers who are ready to cross the bridge. The priority queue is sorted based on the time the worker will finish crossing the bridge and the worker's id. \n\nIn each iteration of the while loop, we check if there are any workers who are ready to cross the bridge (i.e., their crossing time is less than or equal to the current time). If there are, we pop the worker with the highest priority from the priority queue, update the time elapsed, and decrement the number of boxes left. \n\nIf there are still boxes left, we push the worker back into the priority queue with their updated crossing time. We then increment the time elapsed by 1 minute. \n\nThe while loop continues until all the boxes are put in the new warehouse, and the function returns the time elapsed.", "extracted_code": "\nclass Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        workers = sorted([(a+b, a, b, i) for i, (a, b, c, d) in enumerate(time)], key=lambda x: (-x[0], x[3]))\n        time_elapsed = 0\n        boxes_left = n\n        while boxes_left > 0:\n            while len(workers) > 0 and workers[0][0] <= time_elapsed:\n                _, left_time, right_time, worker_id = heapq.heappop(workers)\n                time_elapsed += left_time\n                boxes_left -= 1\n                if boxes_left > 0:\n                    heapq.heappush(workers, (time_elapsed + right_time, left_time, right_time, worker_id))\n            time_elapsed += 1\n        return time_elapsed\n", "difficulty": 3.0}
{"task_id": "LeetCode/2528", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        n = len(stations)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + stations[i]\n\n        max_power = 0\n        for i in range(n):\n            left = max(0, i - r)\n            right = min(n, i + r + 1)\n            total_power = prefix_sum[right] - prefix_sum[left]\n            max_power = max(max_power, total_power)\n\n        if k >= n:\n            return max_power\n\n        for i in range(n):\n            if stations[i] == 0:\n                stations[i] = 1\n                break\n\n        for _ in range(k):\n            max_index = stations.index(max(stations))\n            stations[max_index] += 1\n            for i in range(max(0, max_index - r), min(n, max_index + r + 1)):\n                prefix_sum[i + 1] = prefix_sum[i] + stations[i]\n\n            max_power = max(max_power, prefix_sum[min(n, max_index + r + 1)] - prefix_sum[max(0, max_index - r)])\n\n        return max_power\n```", "extracted_code": "\nclass Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        n = len(stations)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + stations[i]\n\n        max_power = 0\n        for i in range(n):\n            left = max(0, i - r)\n            right = min(n, i + r + 1)\n            total_power = prefix_sum[right] - prefix_sum[left]\n            max_power = max(max_power, total_power)\n\n        if k >= n:\n            return max_power\n\n        for i in range(n):\n            if stations[i] == 0:\n                stations[i] = 1\n                break\n\n        for _ in range(k):\n            max_index = stations.index(max(stations))\n            stations[max_index] += 1\n            for i in range(max(0, max_index - r), min(n, max_index + r + 1)):\n                prefix_sum[i + 1] = prefix_sum[i] + stations[i]\n\n            max_power = max(max_power, prefix_sum[min(n, max_index + r + 1)] - prefix_sum[max(0, max_index - r)])\n\n        return max_power\n", "difficulty": 3.0}
{"task_id": "LeetCode/2514", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n        MOD = 10**9 + 7\n        N = len(s)\n        factorial = [1]*(N+1)\n        for i in range(1, N+1):\n            factorial[i] = factorial[i-1]*i % MOD\n        prefix_hash = [0]*(N+1)\n        for i in range(N):\n            prefix_hash[i+1] = (prefix_hash[i]*26 + ord(s[i]) - ord('a') + 1) % MOD\n        anagram_count = {0: 1}\n        for i in range(1, N+1):\n            for j in range(i, N+1):\n                cur_hash = (prefix_hash[j] - prefix_hash[i-1]*(26**(j-i+1) or 1) + MOD) % MOD\n                anagram_count[cur_hash] = (anagram_count.get(cur_hash, 0) + factorial[i-1]) % MOD\n        return sum(anagram_count.values()) % MOD\n```\n\nThis function calculates the number of distinct anagrams of the given string `s`. It uses a prefix hash to represent the anagram of each substring of `s`. The hash is calculated by multiplying the current hash with 26 (the number of English letters) and adding the ASCII value of the current character minus the ASCII value of 'a' plus 1. The factorial array is used to calculate the number of permutations of each substring. The anagram count is stored in a dictionary, where the key is the hash and the value is the count of anagrams with the same hash. The result is the sum of all values in the anagram count dictionary, modulo `10**9 + 7` to prevent overflow.", "extracted_code": "\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n        MOD = 10**9 + 7\n        N = len(s)\n        factorial = [1]*(N+1)\n        for i in range(1, N+1):\n            factorial[i] = factorial[i-1]*i % MOD\n        prefix_hash = [0]*(N+1)\n        for i in range(N):\n            prefix_hash[i+1] = (prefix_hash[i]*26 + ord(s[i]) - ord('a') + 1) % MOD\n        anagram_count = {0: 1}\n        for i in range(1, N+1):\n            for j in range(i, N+1):\n                cur_hash = (prefix_hash[j] - prefix_hash[i-1]*(26**(j-i+1) or 1) + MOD) % MOD\n                anagram_count[cur_hash] = (anagram_count.get(cur_hash, 0) + factorial[i-1]) % MOD\n        return sum(anagram_count.values()) % MOD\n", "difficulty": 3.0}
{"task_id": "LeetCode/2518", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        total_sum = sum(nums)\n        if total_sum < k:\n            return 0\n        dp = [[0]*(total_sum+1) for _ in range(n+1)]\n        dp[0][0] = 1\n        for i in range(1, n+1):\n            num = nums[i-1]\n            for j in range(total_sum, num-1, -1):\n                for l in range(1, i+1):\n                    dp[i][j] = (dp[i][j] + dp[i-1][j-num]) % mod\n        count = 0\n        for j in range(k, total_sum+1):\n            count = (count + dp[n][j]) % mod\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        total_sum = sum(nums)\n        if total_sum < k:\n            return 0\n        dp = [[0]*(total_sum+1) for _ in range(n+1)]\n        dp[0][0] = 1\n        for i in range(1, n+1):\n            num = nums[i-1]\n            for j in range(total_sum, num-1, -1):\n                for l in range(1, i+1):\n                    dp[i][j] = (dp[i][j] + dp[i-1][j-num]) % mod\n        count = 0\n        for j in range(k, total_sum+1):\n            count = (count + dp[n][j]) % mod\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2509", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        parent = [i for i in range(2**n)]\n        depth = [0 for _ in range(2**n)]\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            root_x = find(x)\n            root_y = find(y)\n            if root_x != root_y:\n                if depth[root_x] < depth[root_y]:\n                    parent[root_x] = root_y\n                elif depth[root_x] > depth[root_y]:\n                    parent[root_y] = root_x\n                else:\n                    parent[root_y] = root_x\n                    depth[root_x] += 1\n        \n        for i in range(2**n - 1, 0, -1):\n            union(i, i//2)\n        \n        ans = []\n        for a, b in queries:\n            if find(a) == find(b):\n                ans.append(depth[find(a)] + depth[find(b)])\n            else:\n                union(a, b)\n                ans.append(depth[find(a)] + depth[find(b)] - 1)\n                parent[find(a)] = a\n                parent[find(b)] = b\n                depth[find(a)] = 0\n                depth[find(b)] = 0\n        return ans\n```", "extracted_code": "\nclass Solution:\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        parent = [i for i in range(2**n)]\n        depth = [0 for _ in range(2**n)]\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            root_x = find(x)\n            root_y = find(y)\n            if root_x != root_y:\n                if depth[root_x] < depth[root_y]:\n                    parent[root_x] = root_y\n                elif depth[root_x] > depth[root_y]:\n                    parent[root_y] = root_x\n                else:\n                    parent[root_y] = root_x\n                    depth[root_x] += 1\n        \n        for i in range(2**n - 1, 0, -1):\n            union(i, i//2)\n        \n        ans = []\n        for a, b in queries:\n            if find(a) == find(b):\n                ans.append(depth[find(a)] + depth[find(b)])\n            else:\n                union(a, b)\n                ans.append(depth[find(a)] + depth[find(b)] - 1)\n                parent[find(a)] = a\n                parent[find(b)] = b\n                depth[find(a)] = 0\n                depth[find(b)] = 0\n        return ans\n", "difficulty": 3.0}
{"task_id": "LeetCode/2508", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        degree = [0] * (n + 1)\n        for u, v in edges:\n            degree[u] += 1\n            degree[v] += 1\n        odd_count = sum(d % 2 for d in degree)\n        return odd_count <= 2\n```\n\nThis function works by first initializing an array `degree` to store the degree of each node. It then iterates over the `edges` list and increments the degree of each node that is connected by an edge. After that, it counts the number of odd degrees in the `degree` list and stores this count in `odd_count`. Finally, it checks if `odd_count` is less than or equal to 2. If it is, it returns `True`, indicating that it is possible to make the degree of each node even. Otherwise, it returns `False`.", "extracted_code": "\nclass Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        degree = [0] * (n + 1)\n        for u, v in edges:\n            degree[u] += 1\n            degree[v] += 1\n        odd_count = sum(d % 2 for d in degree)\n        return odd_count <= 2\n", "difficulty": 3.0}
{"task_id": "LeetCode/2503", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n        m, n = len(grid), len(grid[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        def dfs(x, y, q):\n            visited = [[0] * n for _ in range(m)]\n            stack = [(x, y, 1)]\n            points = 1\n            while stack:\n                nx, ny, np = stack.pop()\n                if np > points:\n                    points = np\n                for dx, dy in directions:\n                    nnx, nny = nx + dx, ny + dy\n                    if 0 <= nnx < m and 0 <= nny < n and not visited[nnx][nny] and grid[nnx][nny] < q:\n                        visited[nnx][nny] = 1\n                        stack.append((nnx, nny, np + 1))\n            return points\n\n        return [dfs(i // n, i % n, q) for i, q in enumerate(queries)]\n```\n\nThis solution uses depth-first search (DFS) to explore all possible moves from the current cell. The `dfs` function takes the current cell's coordinates and the query value as input and returns the maximum number of points that can be obtained. The `visited` matrix keeps track of the cells that have been visited during the current search. The `stack` is used to store the cells to be visited and their corresponding point values. The point value is incremented each time we move to an adjacent cell whose value is less than the query value. The maximum point value obtained during the search is returned as the result. The main function `maxPoints` applies the `dfs` function to each query by converting the linear index to 2D coordinates.", "extracted_code": "\nclass Solution:\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n        m, n = len(grid), len(grid[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        def dfs(x, y, q):\n            visited = [[0] * n for _ in range(m)]\n            stack = [(x, y, 1)]\n            points = 1\n            while stack:\n                nx, ny, np = stack.pop()\n                if np > points:\n                    points = np\n                for dx, dy in directions:\n                    nnx, nny = nx + dx, ny + dy\n                    if 0 <= nnx < m and 0 <= nny < n and not visited[nnx][nny] and grid[nnx][nny] < q:\n                        visited[nnx][nny] = 1\n                        stack.append((nnx, nny, np + 1))\n            return points\n\n        return [dfs(i // n, i % n, q) for i, q in enumerate(queries)]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2499", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        diff = [abs(nums1[i] - nums2[i]) for i in range(n)]\n        total_cost = sum(diff)\n        diff.sort()\n        for i in range(n - 1):\n            total_cost -= diff[i]\n            if total_cost <= 0:\n                return i\n        return total_cost\n```\n\nThis function works by first calculating the absolute difference between the corresponding elements of `nums1` and `nums2`. It then sorts this list of differences. The function iterates through this sorted list of differences, subtracting each difference from a running total (`total_cost`), which initially contains the sum of all differences. If `total_cost` becomes less than or equal to 0 at any point during the iteration, the function returns the current index. If `total_cost` does not become less than or equal to 0 after iterating through all the differences, the function returns `total_cost`.\n\nThis algorithm works because the goal is to minimize the total cost of swapping elements in `nums1` to make it equal to `nums2`. By sorting the differences, we can ensure that we are swapping the elements with the smallest differences first, which will minimize the total cost.\n\nThe time complexity of this function is O(n log n) due to the sorting operation, where n is the length of `nums1` and `nums2`. The space complexity is O(n) for storing the list of differences.", "extracted_code": "\nclass Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        diff = [abs(nums1[i] - nums2[i]) for i in range(n)]\n        total_cost = sum(diff)\n        diff.sort()\n        for i in range(n - 1):\n            total_cost -= diff[i]\n            if total_cost <= 0:\n                return i\n        return total_cost\n", "difficulty": 3.0}
{"task_id": "LeetCode/2493", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import defaultdict\n\nclass Solution:\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        visited = [0] * (n + 1)\n        groups = [0]\n        for node in range(1, n + 1):\n            if not visited[node]:\n                group = set()\n                stack = [node]\n                while stack:\n                    node = stack.pop()\n                    if not visited[node]:\n                        visited[node] = 1\n                        group.add(node)\n                        stack.extend(graph[node])\n                groups.append(len(group))\n        return max(groups) if len(groups) > 1 else -1\n```\n\nThis function uses a depth-first search (DFS) to find all connected components in the graph. It starts by initializing a visited array to keep track of nodes that have been visited, and a list to store the size of each group. For each unvisited node, it performs a DFS, adding all nodes in the same connected component to the same group. After visiting all nodes, it returns the maximum group size if there is more than one group, or -1 otherwise.", "extracted_code": "\nfrom collections import defaultdict\n\nclass Solution:\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        visited = [0] * (n + 1)\n        groups = [0]\n        for node in range(1, n + 1):\n            if not visited[node]:\n                group = set()\n                stack = [node]\n                while stack:\n                    node = stack.pop()\n                    if not visited[node]:\n                        visited[node] = 1\n                        group.add(node)\n                        stack.extend(graph[node])\n                groups.append(len(group))\n        return max(groups) if len(groups) > 1 else -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2488", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        count = 0\n        left, right = 0, 0\n\n        while right < n:\n            if nums[right] < k:\n                right += 1\n            else:\n                left = right\n                while right < n and nums[right] >= k:\n                    right += 1\n                count += (right - left) * (right - left - 1) // 2\n        return count\n```\n\nThis function works by maintaining two pointers, `left` and `right`, which define the current subarray. The `left` pointer is incremented whenever a number smaller than `k` is encountered, and the `right` pointer is incremented whenever a number greater than or equal to `k` is encountered. When the `right` pointer moves forward, it counts the number of subarrays that can be formed with the current `left` and `right` pointers. The count is incremented by the number of subarrays, which is calculated as `(right - left) * (right - left - 1) // 2`. The formula `(right - left) * (right - left - 1) // 2` is used to calculate the number of subarrays with a fixed `left` and varying `right` pointer. The total count is then returned.", "extracted_code": "\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        count = 0\n        left, right = 0, 0\n\n        while right < n:\n            if nums[right] < k:\n                right += 1\n            else:\n                left = right\n                while right < n and nums[right] >= k:\n                    right += 1\n                count += (right - left) * (right - left - 1) // 2\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2484", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countPalindromes(self, s: str) -> int:\n        MOD = 10**9 + 7\n        alphabet_size = 10\n        str_length = len(s)\n        palindrome_count = 0\n\n        # Initialize a 2D array to store counts of characters\n        count = [[0]*alphabet_size for _ in range(str_length)]\n\n        # Fill the count array\n        for i in range(str_length):\n            for j in range(i+1, str_length+1):\n                count[i][int(s[j-1])] += 1\n\n        # Function to calculate palindrome count\n        def palindrome_count_util(start: int, end: int) -> int:\n            nonlocal palindrome_count\n            if start >= end:\n                return 0\n            temp = [0]*alphabet_size\n            for i in range(alphabet_size):\n                temp[i] = count[start][i]\n            for i in range(alphabet_size):\n                count[start][i] -= temp[i]\n            for i in range(start+1, end):\n                for j in range(alphabet_size):\n                    count[i][j] -= temp[j]\n            for i in range(alphabet_size):\n                palindrome_count = (palindrome_count + temp[i]*(temp[i]-1)//2) % MOD\n            palindrome_count_util(start+1, end)\n            for i in range(alphabet_size):\n                count[start][i] += temp[i]\n            for i in range(start+1, end):\n                for j in range(alphabet_size):\n                    count[i][j] += temp[j]\n\n        # Call the function\n        palindrome_count_util(0, str_length)\n\n        return palindrome_count\n```\n\nThis function calculates the number of palindromic subsequences of length 5 in the given string. It uses a 2D array to store the counts of characters in the string and then recursively calculates the palindrome count by updating the counts of characters. The time complexity of this function is O(n^2), where n is the length of the string.", "extracted_code": "\nclass Solution:\n    def countPalindromes(self, s: str) -> int:\n        MOD = 10**9 + 7\n        alphabet_size = 10\n        str_length = len(s)\n        palindrome_count = 0\n\n        # Initialize a 2D array to store counts of characters\n        count = [[0]*alphabet_size for _ in range(str_length)]\n\n        # Fill the count array\n        for i in range(str_length):\n            for j in range(i+1, str_length+1):\n                count[i][int(s[j-1])] += 1\n\n        # Function to calculate palindrome count\n        def palindrome_count_util(start: int, end: int) -> int:\n            nonlocal palindrome_count\n            if start >= end:\n                return 0\n            temp = [0]*alphabet_size\n            for i in range(alphabet_size):\n                temp[i] = count[start][i]\n            for i in range(alphabet_size):\n                count[start][i] -= temp[i]\n            for i in range(start+1, end):\n                for j in range(alphabet_size):\n                    count[i][j] -= temp[j]\n            for i in range(alphabet_size):\n                palindrome_count = (palindrome_count + temp[i]*(temp[i]-1)//2) % MOD\n            palindrome_count_util(start+1, end)\n            for i in range(alphabet_size):\n                count[start][i] += temp[i]\n            for i in range(start+1, end):\n                for j in range(alphabet_size):\n                    count[i][j] += temp[j]\n\n        # Call the function\n        palindrome_count_util(0, str_length)\n\n        return palindrome_count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2478", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\n        MOD = 10**9 + 7\n        primes = {'2', '3', '5', '7'}\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        for i in range(1, len(s) + 1):\n            dp[i] = dp[i - 1] * 2 % MOD\n            if s[i - 1] in primes:\n                dp[i] += dp[i - minLength]\n        return dp[len(s)]\n```\n\nThis function uses dynamic programming to solve the problem. The dp array stores the number of beautiful partitions of the first i characters of s. The base case is when there are no characters, in which case there is one beautiful partition (the empty partition). For each character, we double the number of beautiful partitions from the previous character. If the current character is a prime digit, we also add the number of beautiful partitions from i - minLength characters ago. This is because we can create a new partition that starts with the current prime digit and ends with the non-prime digit that started the previous partition. Finally, we return the number of beautiful partitions of the entire string s.", "extracted_code": "\nclass Solution:\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\n        MOD = 10**9 + 7\n        primes = {'2', '3', '5', '7'}\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        for i in range(1, len(s) + 1):\n            dp[i] = dp[i - 1] * 2 % MOD\n            if s[i - 1] in primes:\n                dp[i] += dp[i - minLength]\n        return dp[len(s)]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2472", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxPalindromes(self, s: str, k: int) -> int:\n        n = len(s)\n        palindrome_count = 0\n        for i in range(k, n+1):\n            for j in range(n-i+1):\n                if s[j:j+i] == s[j:j+i][::-1]:\n                    palindrome_count += 1\n        return palindrome_count\n```\n\nThis function works by iterating over all possible substring lengths from `k` to `n`, where `n` is the length of the input string `s`. For each substring length, it iterates over all possible starting indices of substrings of that length. If the substring at that starting index is a palindrome (i.e., it is equal to its reverse), it increments the count of palindromes. The function finally returns this count.", "extracted_code": "\nclass Solution:\n    def maxPalindromes(self, s: str, k: int) -> int:\n        n = len(s)\n        palindrome_count = 0\n        for i in range(k, n+1):\n            for j in range(n-i+1):\n                if s[j:j+i] == s[j:j+i][::-1]:\n                    palindrome_count += 1\n        return palindrome_count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2468", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def splitMessage(self, message: str, limit: int) -> List[str]:\n        n = len(message)\n        parts = []\n        for i in range(0, n, limit):\n            part = message[i:i+limit]\n            if len(part) < limit:\n                part += ' ' * (limit - len(part))\n            parts.append(f\"{part}<{i//limit + 1}/{n//limit + (i+limit>=n)}>\")\n        return parts\n```", "extracted_code": "\nclass Solution:\n    def splitMessage(self, message: str, limit: int) -> List[str]:\n        n = len(message)\n        parts = []\n        for i in range(0, n, limit):\n            part = message[i:i+limit]\n            if len(part) < limit:\n                part += ' ' * (limit - len(part))\n            parts.append(f\"{part}<{i//limit + 1}/{n//limit + (i+limit>=n)}>\")\n        return parts\n", "difficulty": 3.0}
{"task_id": "LeetCode/2463", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\n        factories = sorted((pos, -lim, lim) for pos, lim in factory)\n        robots = sorted(robot)\n        res, i = 0, 0\n        for r in robots:\n            while i < len(factories) and factories[i][1] < 0:\n                f_pos, f_neg, f_lim = factories[i]\n                if r >= f_pos:\n                    res += r - f_pos\n                    factories[i] = (f_pos, f_neg + 1, f_lim)\n                    if factories[i][1] == 0:\n                        i += 1\n                    break\n                else:\n                    i += 1\n            else:\n                if i < len(factories):\n                    f_pos, f_neg, f_lim = factories[i]\n                    res += abs(r - f_pos)\n                else:\n                    res += abs(r - factories[-1][0])\n        return res\n```\n\nThis solution works by first sorting the factories by their positions and negating their limits (to make the largest limit factory come first). Then it sorts the robots. It iterates over the robots and for each robot, it checks the factories that can still repair robots (their limit is not reached). If the robot's position is greater than or equal to the factory's position, the robot is repaired and doesn't need to move anymore. If the robot's position is less than the factory's position, the robot needs to move to the factory. The total distance is the sum of all these movements.", "extracted_code": "\nclass Solution:\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\n        factories = sorted((pos, -lim, lim) for pos, lim in factory)\n        robots = sorted(robot)\n        res, i = 0, 0\n        for r in robots:\n            while i < len(factories) and factories[i][1] < 0:\n                f_pos, f_neg, f_lim = factories[i]\n                if r >= f_pos:\n                    res += r - f_pos\n                    factories[i] = (f_pos, f_neg + 1, f_lim)\n                    if factories[i][1] == 0:\n                        i += 1\n                    break\n                else:\n                    i += 1\n            else:\n                if i < len(factories):\n                    f_pos, f_neg, f_lim = factories[i]\n                    res += abs(r - f_pos)\n                else:\n                    res += abs(r - factories[-1][0])\n        return res\n", "difficulty": 3.0}
{"task_id": "LeetCode/2458", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\n        def dfs(node, parent):\n            if not node:\n                return\n            node.parent = parent\n            node.height = 1 + max(dfs(node.left, node), dfs(node.right, node))\n            return node.height\n\n        def find(node, val):\n            while node and node.val != val:\n                node = node.left if node.val > val else node.right\n            return node\n\n        def remove(node):\n            if not node:\n                return\n            node.parent.left = node.left if node.parent.left == node else node.right\n            if node.left:\n                node.left.parent = node.parent\n            if node.right:\n                node.right.parent = node.parent\n            node.left, node.right, node.parent = None, None, None\n\n        def height(node):\n            return 0 if not node else node.height\n\n        dfs(root, None)\n        return [height(find(root, val)) for val in queries]\n```\n\nThis solution first performs a depth-first search (DFS) on the tree to calculate the height of each node and store the parent of each node. The `find` function is used to find the node with a given value in the tree. The `remove` function is used to remove the subtree rooted at a given node. The `height` function is used to calculate the height of a given node. Finally, the main function `treeQueries` performs the queries by finding the node corresponding to each query value, removing its subtree, and returning the height of the root node after each removal.", "extracted_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\n        def dfs(node, parent):\n            if not node:\n                return\n            node.parent = parent\n            node.height = 1 + max(dfs(node.left, node), dfs(node.right, node))\n            return node.height\n\n        def find(node, val):\n            while node and node.val != val:\n                node = node.left if node.val > val else node.right\n            return node\n\n        def remove(node):\n            if not node:\n                return\n            node.parent.left = node.left if node.parent.left == node else node.right\n            if node.left:\n                node.left.parent = node.parent\n            if node.right:\n                node.right.parent = node.parent\n            node.left, node.right, node.parent = None, None, None\n\n        def height(node):\n            return 0 if not node else node.height\n\n        dfs(root, None)\n        return [height(find(root, val)) for val in queries]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2454", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\n        stack = []\n        res = [-1] * len(nums)\n        for i, num in enumerate(nums):\n            while stack:\n                if nums[stack[-1]] > num:\n                    res[stack.pop()] = num\n                else:\n                    stack.pop()\n            stack.append(i)\n        return res\n```", "extracted_code": "\nclass Solution:\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\n        stack = []\n        res = [-1] * len(nums)\n        for i, num in enumerate(nums):\n            while stack:\n                if nums[stack[-1]] > num:\n                    res[stack.pop()] = num\n                else:\n                    stack.pop()\n            stack.append(i)\n        return res\n", "difficulty": 3.0}
{"task_id": "LeetCode/2449", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\n        nums_counter = Counter(nums)\n        target_counter = Counter(target)\n        operations = 0\n        for num, freq in nums_counter.items():\n            if num not in target_counter:\n                operations += freq\n            else:\n                operations += abs(freq - target_counter[num])\n        return operations // 2\n```\n\nThis function works by first creating frequency counters for both the `nums` and `target` arrays using Python's built-in `collections.Counter` class. It then iterates over the frequency of each number in the `nums` array. If a number is not present in `target`, it adds the frequency of that number to `operations`. If a number is present in `target`, it adds the absolute difference in their frequencies to `operations`. Finally, it returns `operations` divided by 2, because each operation affects two elements in the array.", "extracted_code": "\nclass Solution:\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\n        nums_counter = Counter(nums)\n        target_counter = Counter(target)\n        operations = 0\n        for num, freq in nums_counter.items():\n            if num not in target_counter:\n                operations += freq\n            else:\n                operations += abs(freq - target_counter[num])\n        return operations // 2\n", "difficulty": 3.0}
{"task_id": "LeetCode/2448", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        n = len(nums)\n        min_num = min(nums)\n        min_index = nums.index(min_num)\n        total_cost = 0\n        \n        for i in range(n):\n            if nums[i] != min_num:\n                diff = abs(nums[i] - min_num)\n                total_cost += cost[i] * diff\n                nums[i] = min_num\n        \n        return total_cost\n```\n\nThis function works by first finding the minimum number in the `nums` array and its index. Then, it iterates over the `nums` array and calculates the difference between each number and the minimum number. If the difference is not zero, it adds the product of the difference and the corresponding cost to the total cost. Finally, it updates the number in the `nums` array to the minimum number. The function returns the total cost.", "extracted_code": "\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        n = len(nums)\n        min_num = min(nums)\n        min_index = nums.index(min_num)\n        total_cost = 0\n        \n        for i in range(n):\n            if nums[i] != min_num:\n                diff = abs(nums[i] - min_num)\n                total_cost += cost[i] * diff\n                nums[i] = min_num\n        \n        return total_cost\n", "difficulty": 3.0}
{"task_id": "LeetCode/2444", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\n        n = len(nums)\n        min_count = [0] * (n + 1)\n        max_count = [0] * (n + 1)\n        min_count[0] = max_count[0] = 1\n        res = 0\n\n        for i in range(1, n + 1):\n            min_count[i] = min_count[i - 1] + (nums[i - 1] == minK)\n            max_count[i] = max_count[i - 1] + (nums[i - 1] == maxK)\n\n        for i in range(n):\n            if nums[i] == minK or nums[i] == maxK:\n                res += min_count[i] * max_count[n] + max_count[i] * min_count[n]\n            else:\n                res += min_count[i] * max_count[i + 1]\n\n        return res\n```", "extracted_code": "\nclass Solution:\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\n        n = len(nums)\n        min_count = [0] * (n + 1)\n        max_count = [0] * (n + 1)\n        min_count[0] = max_count[0] = 1\n        res = 0\n\n        for i in range(1, n + 1):\n            min_count[i] = min_count[i - 1] + (nums[i - 1] == minK)\n            max_count[i] = max_count[i - 1] + (nums[i - 1] == maxK)\n\n        for i in range(n):\n            if nums[i] == minK or nums[i] == maxK:\n                res += min_count[i] * max_count[n] + max_count[i] * min_count[n]\n            else:\n                res += min_count[i] * max_count[i + 1]\n\n        return res\n", "difficulty": 3.0}
{"task_id": "LeetCode/2440", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import defaultdict\n\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            subtree_sum = nums[node]\n            children_count = 1\n            for child in graph[node]:\n                if child != parent:\n                    child_sum, child_count = dfs(child, node)\n                    subtree_sum += child_sum\n                    children_count += child_count\n            return subtree_sum, children_count\n        \n        total_sum, total_count = dfs(0, -1)\n        target_value = total_sum // total_count\n        edges_to_delete = total_sum - target_value * total_count\n        return len(edges) - edges_to_delete\n```\n\nThis solution uses depth-first search (DFS) to traverse the tree and calculate the sum of each subtree. It then calculates the target value for each connected component, which is the total sum divided by the total number of nodes in the component. The number of edges to delete is then calculated as the difference between the total sum and the target value multiplied by the total number of nodes.", "extracted_code": "\nfrom collections import defaultdict\n\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            subtree_sum = nums[node]\n            children_count = 1\n            for child in graph[node]:\n                if child != parent:\n                    child_sum, child_count = dfs(child, node)\n                    subtree_sum += child_sum\n                    children_count += child_count\n            return subtree_sum, children_count\n        \n        total_sum, total_count = dfs(0, -1)\n        target_value = total_sum // total_count\n        edges_to_delete = total_sum - target_value * total_count\n        return len(edges) - edges_to_delete\n", "difficulty": 3.0}
{"task_id": "LeetCode/2435", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1\n        mod = 10**9 + 7\n\n        for i in range(m):\n            for j in range(n):\n                if i > 0:\n                    dp[i][j] = (dp[i][j] + dp[i-1][j]) % mod\n                if j > 0:\n                    dp[i][j] = (dp[i][j] + dp[i][j-1]) % mod\n\n        return dp[m-1][n-1] - sum(dp[i][n-1] for i in range(m-1)) % mod\n```\n\nThis function uses dynamic programming to calculate the number of paths from the top-left corner to the bottom-right corner. The `dp` array stores the number of paths to each cell, and the number of paths to a cell is the sum of the paths to the cell above it and the cell to its left.\n\nThe final result is `dp[m-1][n-1]`, which is the total number of paths from the top-left corner to the bottom-right corner. However, this count includes the paths that do not end at the bottom-right corner but go beyond it. To get the number of paths that end at the bottom-right corner, we subtract the number of paths that end at each cell in the last row, except for the last cell. This is because the number of paths to the last cell in the last row is the total number of paths that end at the bottom-right corner.\n\nThe result is then taken modulo `10**9 + 7` to prevent overflow and to adhere to the problem constraints.", "extracted_code": "\nclass Solution:\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1\n        mod = 10**9 + 7\n\n        for i in range(m):\n            for j in range(n):\n                if i > 0:\n                    dp[i][j] = (dp[i][j] + dp[i-1][j]) % mod\n                if j > 0:\n                    dp[i][j] = (dp[i][j] + dp[i][j-1]) % mod\n\n        return dp[m-1][n-1] - sum(dp[i][n-1] for i in range(m-1)) % mod\n", "difficulty": 3.0}
{"task_id": "LeetCode/2407", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\n        dp = [1] * len(nums)\n        for i in range(len(nums)):\n            for j in range(i):\n                if nums[i] - nums[j] <= k:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n```", "extracted_code": "\nclass Solution:\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\n        dp = [1] * len(nums)\n        for i in range(len(nums)):\n            for j in range(i):\n                if nums[i] - nums[j] <= k:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2430", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def deleteString(self, s: str) -> int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = i\n            for j in range(i):\n                if s[j] == s[i - 1]:\n                    dp[i] = min(dp[i], dp[j] + 1)\n        return n - dp[n]\n```", "extracted_code": "\nclass Solution:\n    def deleteString(self, s: str) -> int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = i\n            for j in range(i):\n                if s[j] == s[i - 1]:\n                    dp[i] = min(dp[i], dp[j] + 1)\n        return n - dp[n]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2426", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\n        count = 0\n        for i in range(len(nums1)):\n            for j in range(i+1, len(nums1)):\n                if nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff:\n                    count += 1\n        return count\n```\n\nThis function works by iterating over each pair of indices `(i, j)` where `i < j`. For each pair, it checks whether the difference between `nums1[i]` and `nums1[j]` is less than or equal to the difference between `nums2[i]` and `nums2[j]` plus `diff`. If this condition is satisfied, it increments a counter. Finally, it returns the counter.\n\nThis algorithm has a time complexity of O(n^2) because it iterates over each pair of indices in the input arrays. This is acceptable given the constraints of the problem, where `n` can be up to 10^5.", "extracted_code": "\nclass Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\n        count = 0\n        for i in range(len(nums1)):\n            for j in range(i+1, len(nums1)):\n                if nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff:\n                    count += 1\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2421", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nimport numpy as np\n\nclass Solution:\n    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:\n        n = len(vals)\n        tree = [[] for _ in range(n)]\n        for u, v in edges:\n            tree[u].append(v)\n            tree[v].append(u)\n        dp = [0] * n\n        dp[0] = 1\n        mod = 10**9 + 7\n\n        def dfs(node, parent):\n            val = vals[node]\n            for child in tree[node]:\n                if child != parent:\n                    dfs(child, node)\n                    dp[node] = (dp[node] + dp[child]) % mod\n                    if vals[child] <= val:\n                        dp[node] = (dp[node] + dp[child]) % mod\n            if node != 0:\n                dp[parent] = (dp[parent] + dp[node]) % mod\n\n        dfs(0, -1)\n        return dp[0]\n```\n\nThis function uses depth-first search (DFS) to traverse the tree and dynamic programming (DP) to store the number of good paths at each node. The DFS function `dfs` is defined to take a node and its parent as input. For each child of the current node, it recursively calls the `dfs` function and then updates the DP array at the current node. The good paths are counted by adding the number of good paths at the child node to the current node's DP value. If the child node's value is less than or equal to the current node's value, it also adds the child node's DP value to the current node's DP value. The DP array is initialized with 0s and the DP value at the root node is set to 1. The function finally returns the DP value at the root node, which represents the total number of good paths in the tree.", "extracted_code": "\nimport numpy as np\n\nclass Solution:\n    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:\n        n = len(vals)\n        tree = [[] for _ in range(n)]\n        for u, v in edges:\n            tree[u].append(v)\n            tree[v].append(u)\n        dp = [0] * n\n        dp[0] = 1\n        mod = 10**9 + 7\n\n        def dfs(node, parent):\n            val = vals[node]\n            for child in tree[node]:\n                if child != parent:\n                    dfs(child, node)\n                    dp[node] = (dp[node] + dp[child]) % mod\n                    if vals[child] <= val:\n                        dp[node] = (dp[node] + dp[child]) % mod\n            if node != 0:\n                dp[parent] = (dp[parent] + dp[node]) % mod\n\n        dfs(0, -1)\n        return dp[0]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2416", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\n        trie = {}\n        for word in words:\n            node = trie\n            for letter in word:\n                node = node.setdefault(letter, {})\n        scores = [0] * len(words)\n        for i, word in enumerate(words):\n            node = trie\n            for letter in word:\n                node = node[letter]\n                for j, other_word in enumerate(words):\n                    if j == i or other_word.startswith(word):\n                        continue\n                    if other_word.startswith(word[:len(other_word)]):\n                        scores[i] += 1\n        return scores\n```", "extracted_code": "\nclass Solution:\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\n        trie = {}\n        for word in words:\n            node = trie\n            for letter in word:\n                node = node.setdefault(letter, {})\n        scores = [0] * len(words)\n        for i, word in enumerate(words):\n            node = trie\n            for letter in word:\n                node = node[letter]\n                for j, other_word in enumerate(words):\n                    if j == i or other_word.startswith(word):\n                        continue\n                    if other_word.startswith(word[:len(other_word)]):\n                        scores[i] += 1\n        return scores\n", "difficulty": 3.0}
{"task_id": "LeetCode/2412", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\n        total_cost = sum(t[0] for t in transactions)\n        total_cashback = sum(t[1] for t in transactions)\n        return max(total_cost - total_cashback, 0)\n```", "extracted_code": "\nclass Solution:\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\n        total_cost = sum(t[0] for t in transactions)\n        total_cashback = sum(t[1] for t in transactions)\n        return max(total_cost - total_cashback, 0)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2402", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\n        room_counts = [0] * n\n        heap = []\n        for start, end in meetings:\n            while heap and heap[0][0] < start:\n                heapq.heappop(heap)\n            room = heapq.heappushpop(heap, (end, len(heap)))[1]\n            room_counts[room] += 1\n        return room_counts.index(max(room_counts))\n```\n\nThis solution uses a priority queue to keep track of the rooms that are currently being used. The priority queue is ordered by the end time of the meeting, with ties broken by the room number. When a new meeting starts, the room with the earliest end time is used. If all rooms are being used, the meeting is delayed until a room becomes available. The room_counts array keeps track of the number of meetings held in each room. The room with the most meetings is then returned.", "extracted_code": "\nclass Solution:\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\n        room_counts = [0] * n\n        heap = []\n        for start, end in meetings:\n            while heap and heap[0][0] < start:\n                heapq.heappop(heap)\n            room = heapq.heappushpop(heap, (end, len(heap)))[1]\n            room_counts[room] += 1\n        return room_counts.index(max(room_counts))\n", "difficulty": 3.0}
{"task_id": "LeetCode/2398", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\n        n = len(chargeTimes)\n        robots = sorted(zip(chargeTimes, runningCosts), key=lambda x: x[0])\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + robots[i][1]\n        l, r = 0, n\n        while l < r:\n            m = (l + r + 1) // 2\n            if self.check(robots, prefix_sum, m, budget):\n                l = m\n            else:\n                r = m - 1\n        return l\n\n    def check(self, robots, prefix_sum, m, budget):\n        total_charge = robots[m - 1][0]\n        total_running = prefix_sum[m] - prefix_sum[m - 1]\n        for i in range(m - 1, -1, -1):\n            total_charge = max(total_charge, robots[i][0])\n            total_running += robots[i][1]\n            if total_charge + total_running * (m - i) <= budget:\n                return True\n            else:\n                return False\n```", "extracted_code": "\nclass Solution:\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\n        n = len(chargeTimes)\n        robots = sorted(zip(chargeTimes, runningCosts), key=lambda x: x[0])\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + robots[i][1]\n        l, r = 0, n\n        while l < r:\n            m = (l + r + 1) // 2\n            if self.check(robots, prefix_sum, m, budget):\n                l = m\n            else:\n                r = m - 1\n        return l\n\n    def check(self, robots, prefix_sum, m, budget):\n        total_charge = robots[m - 1][0]\n        total_running = prefix_sum[m] - prefix_sum[m - 1]\n        for i in range(m - 1, -1, -1):\n            total_charge = max(total_charge, robots[i][0])\n            total_running += robots[i][1]\n            if total_charge + total_running * (m - i) <= budget:\n                return True\n            else:\n                return False\n", "difficulty": 3.0}
{"task_id": "LeetCode/2392", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n        matrix = [[0]*k for _ in range(k)]\n        row_map = {i: [] for i in range(1, k+1)}\n        col_map = {i: [] for i in range(1, k+1)}\n        \n        for condition in rowConditions:\n            above, below = condition\n            row_map[above].append(below)\n            row_map[below].append(above)\n        \n        for condition in colConditions:\n            left, right = condition\n            col_map[left].append(right)\n            col_map[right].append(left)\n        \n        for i in range(1, k+1):\n            if len(row_map[i]) != len(col_map[i]):\n                return []\n        \n        for i in range(1, k+1):\n            for j in range(k):\n                if matrix[j][i-1] == 0:\n                    matrix[j][i-1] = i\n                    break\n        \n        for i in range(1, k+1):\n            for j in range(k-1, -1, -1):\n                if matrix[j][i-1] == 0:\n                    matrix[j][i-1] = i\n                    break\n        \n        return matrix\n```", "extracted_code": "\nclass Solution:\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n        matrix = [[0]*k for _ in range(k)]\n        row_map = {i: [] for i in range(1, k+1)}\n        col_map = {i: [] for i in range(1, k+1)}\n        \n        for condition in rowConditions:\n            above, below = condition\n            row_map[above].append(below)\n            row_map[below].append(above)\n        \n        for condition in colConditions:\n            left, right = condition\n            col_map[left].append(right)\n            col_map[right].append(left)\n        \n        for i in range(1, k+1):\n            if len(row_map[i]) != len(col_map[i]):\n                return []\n        \n        for i in range(1, k+1):\n            for j in range(k):\n                if matrix[j][i-1] == 0:\n                    matrix[j][i-1] = i\n                    break\n        \n        for i in range(1, k+1):\n            for j in range(k-1, -1, -1):\n                if matrix[j][i-1] == 0:\n                    matrix[j][i-1] = i\n                    break\n        \n        return matrix\n", "difficulty": 3.0}
{"task_id": "LeetCode/2386", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nimport numpy as np\n\nclass Solution:\n    def kSum(self, nums: List[int], k: int) -> int:\n        nums = sorted(nums)\n        n = len(nums)\n        presum = np.zeros(n + 1)\n        for i in range(n):\n            presum[i + 1] = presum[i] + nums[i]\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(min(i, k) + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n                if j >= 1:\n                    dp[i][j] -= dp[i - 1][j - 1]\n                if j >= 2:\n                    dp[i][j] += dp[i - 1][j - 2] * (presum[i - 1] - (j - 2) * nums[i - 1])\n        return dp[n][k]\n```\n\nThis function uses dynamic programming to solve the problem. The `dp[i][j]` represents the number of ways to choose a subsequence from the first `i` elements, with `j` as the sum. The transition is done by considering three cases: not choosing the `i-th` element, choosing the `i-th` element once, and choosing the `i-th` element twice. The time complexity is O(n^2 * k), and the space complexity is O(n * k).", "extracted_code": "\nimport numpy as np\n\nclass Solution:\n    def kSum(self, nums: List[int], k: int) -> int:\n        nums = sorted(nums)\n        n = len(nums)\n        presum = np.zeros(n + 1)\n        for i in range(n):\n            presum[i + 1] = presum[i] + nums[i]\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(min(i, k) + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n                if j >= 1:\n                    dp[i][j] -= dp[i - 1][j - 1]\n                if j >= 2:\n                    dp[i][j] += dp[i - 1][j - 2] * (presum[i - 1] - (j - 2) * nums[i - 1])\n        return dp[n][k]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2382", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\n        prefix_sum = [0] * (len(nums) + 1)\n        for i in range(len(nums)):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n\n        max_sum = 0\n        answer = [0] * len(removeQueries)\n        for i in range(len(removeQueries) - 1, -1, -1):\n            remove_index = removeQueries[i]\n            max_sum = max(max_sum, prefix_sum[remove_index + 1] - prefix_sum[remove_index])\n            answer[i] = max_sum\n\n        return answer[::-1]\n```", "extracted_code": "\nclass Solution:\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\n        prefix_sum = [0] * (len(nums) + 1)\n        for i in range(len(nums)):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n\n        max_sum = 0\n        answer = [0] * len(removeQueries)\n        for i in range(len(removeQueries) - 1, -1, -1):\n            remove_index = removeQueries[i]\n            max_sum = max(max_sum, prefix_sum[remove_index + 1] - prefix_sum[remove_index])\n            answer[i] = max_sum\n\n        return answer[::-1]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2376", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSpecialNumbers(self, n: int) -> int:\n        return sum(len(set(str(i))) == len(str(i)) for i in range(1, n+1))\n```", "extracted_code": "\nclass Solution:\n    def countSpecialNumbers(self, n: int) -> int:\n        return sum(len(set(str(i))) == len(str(i)) for i in range(1, n+1))\n", "difficulty": 3.0}
{"task_id": "LeetCode/2366", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumReplacement(self, nums: List[int]) -> int:\n        n = len(nums)\n        operations = 0\n        stack = []\n        for i in range(n):\n            while stack and nums[i] < nums[stack[-1]]:\n                idx = stack.pop()\n                x = nums[idx] - nums[i]\n                operations += (x + 1) // 2\n                nums[idx] = nums[i]\n            stack.append(i)\n        return operations\n```", "extracted_code": "\nclass Solution:\n    def minimumReplacement(self, nums: List[int]) -> int:\n        n = len(nums)\n        operations = 0\n        stack = []\n        for i in range(n):\n            while stack and nums[i] < nums[stack[-1]]:\n                idx = stack.pop()\n                x = nums[idx] - nums[i]\n                operations += (x + 1) // 2\n                nums[idx] = nums[i]\n            stack.append(i)\n        return operations\n", "difficulty": 3.0}
{"task_id": "LeetCode/2360", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        n = len(edges)\n        visited = [0] * n\n        longest_cycle = 0\n\n        for i in range(n):\n            if visited[i] == 0:\n                node = i\n                cycle_length = 0\n                while True:\n                    visited[node] = 1\n                    next_node = edges[node]\n                    if next_node == -1 or visited[next_node] == 2:\n                        break\n                    if visited[next_node] == 1:\n                        cycle_length += 1\n                        break\n                    node = next_node\n                    cycle_length += 1\n                if cycle_length > 0:\n                    longest_cycle = max(longest_cycle, cycle_length)\n                    while True:\n                        visited[node] = 2\n                        next_node = edges[node]\n                        if next_node == -1 or visited[next_node] != 1:\n                            break\n                        node = next_node\n\n        return longest_cycle if longest_cycle > 0 else -1\n```", "extracted_code": "\nclass Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        n = len(edges)\n        visited = [0] * n\n        longest_cycle = 0\n\n        for i in range(n):\n            if visited[i] == 0:\n                node = i\n                cycle_length = 0\n                while True:\n                    visited[node] = 1\n                    next_node = edges[node]\n                    if next_node == -1 or visited[next_node] == 2:\n                        break\n                    if visited[next_node] == 1:\n                        cycle_length += 1\n                        break\n                    node = next_node\n                    cycle_length += 1\n                if cycle_length > 0:\n                    longest_cycle = max(longest_cycle, cycle_length)\n                    while True:\n                        visited[node] = 2\n                        next_node = edges[node]\n                        if next_node == -1 or visited[next_node] != 1:\n                            break\n                        node = next_node\n\n        return longest_cycle if longest_cycle > 0 else -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2354", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\n        from collections import Counter\n        from itertools import combinations\n\n        n = len(nums)\n        cnt = Counter(nums)\n        ans = 0\n\n        for x, y in combinations(cnt, 2):\n            if x & y == 0:\n                ans += cnt[x] * cnt[y]\n            else:\n                ans += cnt[x] * cnt[y] - cnt[x & y]\n\n        return ans // 2 >= k\n```\n\nThis function first counts the frequency of each number in the input array using `collections.Counter`. Then, it generates all possible pairs of distinct numbers using `itertools.combinations`. For each pair `(x, y)`, it checks if `x & y == 0` (i.e., `x AND y` is 0). If so, it adds the product of their frequencies to the answer. Otherwise, it subtracts the frequency of `x & y` from the product of their frequencies, because these pairs have already been counted in the previous step. Finally, it returns `True` if the total number of excellent pairs is greater than or equal to `k`, and `False` otherwise.", "extracted_code": "\nclass Solution:\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\n        from collections import Counter\n        from itertools import combinations\n\n        n = len(nums)\n        cnt = Counter(nums)\n        ans = 0\n\n        for x, y in combinations(cnt, 2):\n            if x & y == 0:\n                ans += cnt[x] * cnt[y]\n            else:\n                ans += cnt[x] * cnt[y] - cnt[x & y]\n\n        return ans // 2 >= k\n", "difficulty": 3.0}
{"task_id": "LeetCode/2350", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\n\nclass Solution:\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\n        freq = [0] * k\n        for roll in rolls:\n            freq[roll - 1] += 1\n        for i in range(k - 1, -1, -1):\n            if freq[i] > 0:\n                for j in range(i + 1, k):\n                    freq[j] -= freq[i]\n                return i + 1\n        return k + 1\n```\n\nThis function works by first counting the frequency of each number from 1 to k in the rolls array. Then, it iterates from the highest number to the lowest, checking if the frequency of the current number is greater than 0. If it is, it subtracts the frequency of the current number from the frequencies of all numbers greater than the current number, and returns the current number plus 1 as the length of the shortest sequence that cannot be taken from rolls. If no number has a frequency greater than 0, it returns k + 1 as the length of the shortest sequence that cannot be taken from rolls.", "extracted_code": "\nfrom typing import List\n\nclass Solution:\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\n        freq = [0] * k\n        for roll in rolls:\n            freq[roll - 1] += 1\n        for i in range(k - 1, -1, -1):\n            if freq[i] > 0:\n                for j in range(i + 1, k):\n                    freq[j] -= freq[i]\n                return i + 1\n        return k + 1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2344", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\n        nums.sort()\n        smallest = nums[0]\n        deletions = 0\n        for num in numsDivide:\n            if num % smallest != 0:\n                while num % smallest != 0:\n                    smallest += 1\n                    deletions += 1\n        if smallest > max(numsDivide):\n            return -1\n        return deletions\n```", "extracted_code": "\nclass Solution:\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\n        nums.sort()\n        smallest = nums[0]\n        deletions = 0\n        for num in numsDivide:\n            if num % smallest != 0:\n                while num % smallest != 0:\n                    smallest += 1\n                    deletions += 1\n        if smallest > max(numsDivide):\n            return -1\n        return deletions\n", "difficulty": 3.0}
{"task_id": "LeetCode/2338", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def idealArrays(self, n: int, maxValue: int) -> int:\n        mod = 10**9 + 7\n        dp = [[0]*(maxValue+1) for _ in range(n+1)]\n        dp[0][0] = 1\n        for i in range(1, n+1):\n            for j in range(1, maxValue+1):\n                dp[i][j] = (dp[i][j-1] + dp[i-1][j]) % mod\n                if j <= i:\n                    dp[i][j] += dp[i-1][j-1] % mod\n        return sum(dp[n]) % mod\n```\n\nThis function uses dynamic programming to calculate the number of distinct ideal arrays of length `n`. The `dp` array stores the number of distinct ideal arrays for each possible length `i` and each possible last value `j`. The inner loop calculates the number of distinct ideal arrays for each possible last value `j` and each possible length `i`. The final result is the sum of all possible distinct ideal arrays of length `n`.", "extracted_code": "\nclass Solution:\n    def idealArrays(self, n: int, maxValue: int) -> int:\n        mod = 10**9 + 7\n        dp = [[0]*(maxValue+1) for _ in range(n+1)]\n        dp[0][0] = 1\n        for i in range(1, n+1):\n            for j in range(1, maxValue+1):\n                dp[i][j] = (dp[i][j-1] + dp[i-1][j]) % mod\n                if j <= i:\n                    dp[i][j] += dp[i-1][j-1] % mod\n        return sum(dp[n]) % mod\n", "difficulty": 3.0}
{"task_id": "LeetCode/2334", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\n        n = len(nums)\n        min_sum = float('inf')\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        for k in range(1, n + 1):\n            for i in range(n - k + 1):\n                if prefix_sum[i + k] - prefix_sum[i] > threshold:\n                    min_sum = min(min_sum, k)\n                    break\n        return -1 if min_sum == float('inf') else min_sum\n```", "extracted_code": "\nclass Solution:\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\n        n = len(nums)\n        min_sum = float('inf')\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        for k in range(1, n + 1):\n            for i in range(n - k + 1):\n                if prefix_sum[i + k] - prefix_sum[i] > threshold:\n                    min_sum = min(min_sum, k)\n                    break\n        return -1 if min_sum == float('inf') else min_sum\n", "difficulty": 3.0}
{"task_id": "LeetCode/2328", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countPaths(self, grid: List[List[int]]) -> int:\n        MOD = 10**9 + 7\n        m, n = len(grid), len(grid[0])\n        dp = [[0]*n for _ in range(m)]\n        dp[0][0] = 1\n        for i in range(m):\n            for j in range(n):\n                if i:\n                    dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD\n                if j:\n                    dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD\n        return dp[-1][-1]\n```\n\nThis solution uses dynamic programming to count the number of strictly increasing paths in the grid. It initializes a 2D dp array with the same dimensions as the input grid, and sets the starting cell (0,0) to 1. Then, for each cell, it adds the number of paths to reach that cell from the cell above it and the cell to its left, modulo 10^9 + 7. The result is the value in the bottom-right cell of the dp array, which represents the total number of strictly increasing paths in the grid.", "extracted_code": "\nclass Solution:\n    def countPaths(self, grid: List[List[int]]) -> int:\n        MOD = 10**9 + 7\n        m, n = len(grid), len(grid[0])\n        dp = [[0]*n for _ in range(m)]\n        dp[0][0] = 1\n        for i in range(m):\n            for j in range(n):\n                if i:\n                    dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD\n                if j:\n                    dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD\n        return dp[-1][-1]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2322", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\n\nclass Solution:\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\n        n = len(nums)\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        def dfs(node, parent):\n            xor = nums[node]\n            for child in graph[node]:\n                if child != parent:\n                    xor ^= dfs(child, node)\n            return xor\n\n        min_score = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                score = dfs(i, -1) ^ dfs(j, -1)\n                min_score = min(min_score, score)\n\n        return min_score\n```\n\nThis solution first builds an adjacency list representation of the tree. Then, it defines a recursive depth-first search function that computes the XOR of all nodes in a subtree rooted at a given node. The function then iterates over all pairs of nodes and computes the score for removing the edges between them. The minimum score over all pairs is returned.", "extracted_code": "\nfrom typing import List\n\nclass Solution:\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\n        n = len(nums)\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        def dfs(node, parent):\n            xor = nums[node]\n            for child in graph[node]:\n                if child != parent:\n                    xor ^= dfs(child, node)\n            return xor\n\n        min_score = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                score = dfs(i, -1) ^ dfs(j, -1)\n                min_score = min(min_score, score)\n\n        return min_score\n", "difficulty": 3.0}
{"task_id": "LeetCode/2318", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distinctSequences(self, n: int) -> int:\n        MOD = 10**9 + 7\n        dp = [0] * (n+1)\n        dp[0] = 1\n        for i in range(1, n+1):\n            dp[i] = (dp[i-1] * 6) % MOD\n            if i >= 2:\n                dp[i] = (dp[i] - dp[i-2] * 5) % MOD\n            if i >= 3:\n                dp[i] = (dp[i] + dp[i-3] * 4) % MOD\n            if i >= 4:\n                dp[i] = (dp[i] - dp[i-4] * 3) % MOD\n            if i >= 5:\n                dp[i] = (dp[i] + dp[i-5] * 2) % MOD\n            if i >= 6:\n                dp[i] = (dp[i] - dp[i-6] + MOD) % MOD\n        return dp[n]\n```\n\nThis function uses dynamic programming to calculate the number of distinct sequences. The dp array stores the number of distinct sequences of length i. The base case is dp[0] = 1, representing the empty sequence. For each length from 1 to n, we calculate the number of distinct sequences by considering all possible last dice values and the number of ways to fill the remaining length-i-1 sequence. We subtract the number of sequences with the same last two dice values, and add back in the number of sequences with the same last three, four, five, and six dice values to ensure the conditions are satisfied. The final result is dp[n], the number of distinct sequences of length n.", "extracted_code": "\nclass Solution:\n    def distinctSequences(self, n: int) -> int:\n        MOD = 10**9 + 7\n        dp = [0] * (n+1)\n        dp[0] = 1\n        for i in range(1, n+1):\n            dp[i] = (dp[i-1] * 6) % MOD\n            if i >= 2:\n                dp[i] = (dp[i] - dp[i-2] * 5) % MOD\n            if i >= 3:\n                dp[i] = (dp[i] + dp[i-3] * 4) % MOD\n            if i >= 4:\n                dp[i] = (dp[i] - dp[i-4] * 3) % MOD\n            if i >= 5:\n                dp[i] = (dp[i] + dp[i-5] * 2) % MOD\n            if i >= 6:\n                dp[i] = (dp[i] - dp[i-6] + MOD) % MOD\n        return dp[n]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2306", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distinctNames(self, ideas: List[str]) -> int:\n        n = len(ideas)\n        valid_names = set()\n        for i in range(n):\n            for j in range(i+1, n):\n                name_A, name_B = ideas[i], ideas[j]\n                new_name_A, new_name_B = name_A[0] + name_B[1:], name_B[0] + name_A[1:]\n                if new_name_A not in ideas and new_name_B not in ideas:\n                    valid_names.add(new_name_A + ' ' + new_name_B)\n        return len(valid_names)\n```\n\nThis function works by iterating over all pairs of distinct names in the input list. For each pair, it swaps the first letters of the two names and checks if the new names are not present in the original list. If they are not, it adds the concatenated string of the new names to a set. The function finally returns the size of the set, which represents the number of distinct valid names for the company.", "extracted_code": "\nclass Solution:\n    def distinctNames(self, ideas: List[str]) -> int:\n        n = len(ideas)\n        valid_names = set()\n        for i in range(n):\n            for j in range(i+1, n):\n                name_A, name_B = ideas[i], ideas[j]\n                new_name_A, new_name_B = name_A[0] + name_B[1:], name_B[0] + name_A[1:]\n                if new_name_A not in ideas and new_name_B not in ideas:\n                    valid_names.add(new_name_A + ' ' + new_name_B)\n        return len(valid_names)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2302", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                score = (prefix_sum[j] - prefix_sum[i]) * (j - i)\n                if score < k:\n                    count += 1\n        return count\n```\n\nThis function works by first calculating the prefix sum of the input array. Then, it iterates over all possible subarrays of the input array and calculates their score. If the score is less than `k`, it increments a counter. Finally, it returns the counter.\n\nThe time complexity of this function is O(n^2), where n is the length of the input array. This is because it needs to iterate over all possible subarrays of the input array. The space complexity is O(n), due to the use of the prefix sum array.", "extracted_code": "\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                score = (prefix_sum[j] - prefix_sum[i]) * (j - i)\n                if score < k:\n                    count += 1\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2301", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\n        mapping_dict = {old: new for old, new in mappings}\n        sub = ''.join(mapping_dict.get(c, c) for c in sub)\n        return sub in s\n```", "extracted_code": "\nclass Solution:\n    def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\n        mapping_dict = {old: new for old, new in mappings}\n        sub = ''.join(mapping_dict.get(c, c) for c in sub)\n        return sub in s\n", "difficulty": 3.0}
{"task_id": "LeetCode/2296", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass TextEditor:\n    def __init__(self):\n        self.text = ''\n        self.cursor = 0\n\n    def addText(self, text: str) -> None:\n        self.text = self.text[:self.cursor] + text + self.text[self.cursor:]\n        self.cursor += len(text)\n\n    def deleteText(self, k: int) -> int:\n        count = min(k, self.cursor)\n        self.text = self.text[:self.cursor - count] + self.text[self.cursor:]\n        self.cursor -= count\n        return count\n\n    def cursorLeft(self, k: int) -> str:\n        self.cursor = max(0, self.cursor - k)\n        return self.text[max(0, self.cursor - 10):self.cursor]\n\n    def cursorRight(self, k: int) -> str:\n        self.cursor = min(len(self.text), self.cursor + k)\n        return self.text[max(0, self.cursor - 10):self.cursor]\n```", "extracted_code": "\nclass TextEditor:\n    def __init__(self):\n        self.text = ''\n        self.cursor = 0\n\n    def addText(self, text: str) -> None:\n        self.text = self.text[:self.cursor] + text + self.text[self.cursor:]\n        self.cursor += len(text)\n\n    def deleteText(self, k: int) -> int:\n        count = min(k, self.cursor)\n        self.text = self.text[:self.cursor - count] + self.text[self.cursor:]\n        self.cursor -= count\n        return count\n\n    def cursorLeft(self, k: int) -> str:\n        self.cursor = max(0, self.cursor - k)\n        return self.text[max(0, self.cursor - 10):self.cursor]\n\n    def cursorRight(self, k: int) -> str:\n        self.cursor = min(len(self.text), self.cursor + k)\n        return self.text[max(0, self.cursor - 10):self.cursor]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2290", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        visited = [[0]*n for _ in range(m)]\n        heap = [(grid[0][0], 0, 0)]\n        visited[0][0] = 1\n        min_obstacles = float('inf')\n\n        while heap:\n            cost, x, y = heapq.heappop(heap)\n            if x == m-1 and y == n-1:\n                min_obstacles = min(min_obstacles, cost)\n            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:\n                    visited[nx][ny] = 1\n                    heapq.heappush(heap, (cost + grid[nx][ny], nx, ny))\n\n        return min_obstacles if min_obstacles != float('inf') else -1\n```\n\nThis solution uses a priority queue to find the minimum number of obstacles to remove. The priority queue is implemented using the heapq module in Python. The algorithm starts at the top-left corner of the grid and explores the grid in all four directions (up, down, left, right). For each cell, it adds the cost of the cell to the cost of the current path and pushes the new path into the priority queue. If the destination cell is reached, it updates the minimum number of obstacles to remove. The algorithm continues until all possible paths have been explored. If no path can reach the destination cell, it returns -1.", "extracted_code": "\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        visited = [[0]*n for _ in range(m)]\n        heap = [(grid[0][0], 0, 0)]\n        visited[0][0] = 1\n        min_obstacles = float('inf')\n\n        while heap:\n            cost, x, y = heapq.heappop(heap)\n            if x == m-1 and y == n-1:\n                min_obstacles = min(min_obstacles, cost)\n            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:\n                    visited[nx][ny] = 1\n                    heapq.heappush(heap, (cost + grid[nx][ny], nx, ny))\n\n        return min_obstacles if min_obstacles != float('inf') else -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2286", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\n\nclass BookMyShow:\n\n    def __init__(self, n: int, m: int):\n        self.n = n\n        self.m = m\n        self.rows = [ [0]*m for _ in range(n)]\n\n    def gather(self, k: int, maxRow: int) -> List[int]:\n        for r in range(min(maxRow+1, self.n)):\n            for c in range(self.m-k+1):\n                if all(self.rows[r][c+i] == 0 for i in range(k)):\n                    for i in range(k):\n                        self.rows[r][c+i] = 1\n                    return [r, c]\n        return []\n\n    def scatter(self, k: int, maxRow: int) -> bool:\n        for r in range(min(maxRow+1, self.n)):\n            cnt, c = 0, 0\n            while cnt < k and c < self.m:\n                if self.rows[r][c] == 0:\n                    cnt += 1\n                else:\n                    cnt, c = 0, c+1\n            if cnt == k:\n                for i in range(c-cnt, c):\n                    self.rows[r][i] = 1\n                return True\n        return False\n```\n\nThis solution uses a 2D list to represent the seats in the hall. The `gather` method iterates over each row and each possible starting seat for a group of `k` spectators, checking if the group can be seated together. If it can, it seates the group and returns the row and starting seat. The `scatter` method iterates over each row and each possible starting seat for a group of `k` spectators, checking if the group can be seated. If it can, it seates the group and returns `True`. If no seating is possible, it returns `False`.", "extracted_code": "\nfrom typing import List\n\nclass BookMyShow:\n\n    def __init__(self, n: int, m: int):\n        self.n = n\n        self.m = m\n        self.rows = [ [0]*m for _ in range(n)]\n\n    def gather(self, k: int, maxRow: int) -> List[int]:\n        for r in range(min(maxRow+1, self.n)):\n            for c in range(self.m-k+1):\n                if all(self.rows[r][c+i] == 0 for i in range(k)):\n                    for i in range(k):\n                        self.rows[r][c+i] = 1\n                    return [r, c]\n        return []\n\n    def scatter(self, k: int, maxRow: int) -> bool:\n        for r in range(min(maxRow+1, self.n)):\n            cnt, c = 0, 0\n            while cnt < k and c < self.m:\n                if self.rows[r][c] == 0:\n                    cnt += 1\n                else:\n                    cnt, c = 0, c+1\n            if cnt == k:\n                for i in range(c-cnt, c):\n                    self.rows[r][i] = 1\n                return True\n        return False\n", "difficulty": 3.0}
{"task_id": "LeetCode/2281", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def totalStrength(self, strength: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(strength)\n        prefix_sum = [0]*(n+1)\n        for i in range(n):\n            prefix_sum[i+1] = prefix_sum[i] + strength[i]\n        dp = [0]*(n+1)\n        for i in range(1, n+1):\n            dp[i] = min(strength[i-1], dp[i-1] + strength[i-1]) * (prefix_sum[i] - prefix_sum[i-1])\n            if i >= 2:\n                dp[i] += dp[i-2]\n            dp[i] %= MOD\n        return dp[-1]\n```", "extracted_code": "\nclass Solution:\n    def totalStrength(self, strength: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(strength)\n        prefix_sum = [0]*(n+1)\n        for i in range(n):\n            prefix_sum[i+1] = prefix_sum[i] + strength[i]\n        dp = [0]*(n+1)\n        for i in range(1, n+1):\n            dp[i] = min(strength[i-1], dp[i-1] + strength[i-1]) * (prefix_sum[i] - prefix_sum[i-1])\n            if i >= 2:\n                dp[i] += dp[i-2]\n            dp[i] %= MOD\n        return dp[-1]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2276", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass CountIntervals:\n\n    def __init__(self):\n        self.intervals = []\n\n    def add(self, left: int, right: int) -> None:\n        self.intervals.append((left, right))\n\n    def count(self) -> int:\n        self.intervals.sort()\n        count = 0\n        end = 0\n        for left, right in self.intervals:\n            if left > end:\n                count += left - end\n            end = max(end, right)\n        return count", "extracted_code": "\nclass CountIntervals:\n\n    def __init__(self):\n        self.intervals = []\n\n    def add(self, left: int, right: int) -> None:\n        self.intervals.append((left, right))\n\n    def count(self) -> int:\n        self.intervals.sort()\n        count = 0\n        end = 0\n        for left, right in self.intervals:\n            if left > end:\n                count += left - end\n            end = max(end, right)\n        return count", "difficulty": 3.0}
{"task_id": "LeetCode/2272", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def largestVariance(self, s: str) -> int:\n        from collections import Counter\n        n = len(s)\n        cnt = Counter(s)\n        cnt = sorted(cnt.values())\n        l, r = 0, n - 1\n        res = 0\n        while l < r:\n            res = max(res, cnt[r] - cnt[l])\n            if cnt[l] < cnt[r]:\n                l += 1\n            else:\n                r -= 1\n        return res\n```", "extracted_code": "\nclass Solution:\n    def largestVariance(self, s: str) -> int:\n        from collections import Counter\n        n = len(s)\n        cnt = Counter(s)\n        cnt = sorted(cnt.values())\n        l, r = 0, n - 1\n        res = 0\n        while l < r:\n            res = max(res, cnt[r] - cnt[l])\n            if cnt[l] < cnt[r]:\n                l += 1\n            else:\n                r -= 1\n        return res\n", "difficulty": 3.0}
{"task_id": "LeetCode/2267", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1 if grid[0][0] == '(' else -1\n\n        for i in range(1, m):\n            if grid[i][0] == '(':\n                dp[i][0] = dp[i-1][0] + 1\n            elif grid[i][0] == ')':\n                dp[i][0] = dp[i-1][0] - 1\n            if dp[i][0] < 0:\n                return False\n\n        for j in range(1, n):\n            if grid[0][j] == '(':\n                dp[0][j] = dp[0][j-1] + 1\n            elif grid[0][j] == ')':\n                dp[0][j] = dp[0][j-1] - 1\n            if dp[0][j] < 0:\n                return False\n\n        for i in range(1, m):\n            for j in range(1, n):\n                if grid[i][j] == '(':\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n                elif grid[i][j] == ')':\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) - 1\n                if dp[i][j] < 0:\n                    return False\n\n        return dp[-1][-1] == 0\n```", "extracted_code": "\nclass Solution:\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1 if grid[0][0] == '(' else -1\n\n        for i in range(1, m):\n            if grid[i][0] == '(':\n                dp[i][0] = dp[i-1][0] + 1\n            elif grid[i][0] == ')':\n                dp[i][0] = dp[i-1][0] - 1\n            if dp[i][0] < 0:\n                return False\n\n        for j in range(1, n):\n            if grid[0][j] == '(':\n                dp[0][j] = dp[0][j-1] + 1\n            elif grid[0][j] == ')':\n                dp[0][j] = dp[0][j-1] - 1\n            if dp[0][j] < 0:\n                return False\n\n        for i in range(1, m):\n            for j in range(1, n):\n                if grid[i][j] == '(':\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n                elif grid[i][j] == ')':\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) - 1\n                if dp[i][j] < 0:\n                    return False\n\n        return dp[-1][-1] == 0\n", "difficulty": 3.0}
{"task_id": "LeetCode/2262", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def appealSum(self, s: str) -> int:\n        n = len(s)\n        total_appeal = 0\n        for i in range(n):\n            appeal = set()\n            for j in range(i, n):\n                appeal.add(s[j])\n                total_appeal += len(appeal)\n        return total_appeal\n```", "extracted_code": "\nclass Solution:\n    def appealSum(self, s: str) -> int:\n        n = len(s)\n        total_appeal = 0\n        for i in range(n):\n            appeal = set()\n            for j in range(i, n):\n                appeal.add(s[j])\n                total_appeal += len(appeal)\n        return total_appeal\n", "difficulty": 3.0}
{"task_id": "LeetCode/2258", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        fire_cells = [(grid[i][j], i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n        heapq.heapify(fire_cells)\n        visited = [[0]*n for _ in range(m)]\n        visited[0][0] = 1\n        min_minutes = 0\n\n        while fire_cells:\n            fire_value, i, j = heapq.heappop(fire_cells)\n            for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\n                if 0 <= x < m and 0 <= y < n and not visited[x][y]:\n                    visited[x][y] = 1\n                    if (x, y) == (m-1, n-1):\n                        return min_minutes + 1\n                    heapq.heappush(fire_cells, (fire_value+1, x, y))\n            min_minutes += 1\n\n        return -1\n```\n\nThis function uses a priority queue to keep track of the cells that are on fire. It starts from the top-left cell and tries to reach the bottom-right cell. For each minute, it spreads the fire to all adjacent cells that are not walls. If the fire reaches the safehouse, it returns the number of minutes it took to reach there. If it is impossible to reach the safehouse, it returns -1. If the fire can always reach the safehouse regardless of the minutes stayed, it returns 10^9.", "extracted_code": "\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        fire_cells = [(grid[i][j], i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n        heapq.heapify(fire_cells)\n        visited = [[0]*n for _ in range(m)]\n        visited[0][0] = 1\n        min_minutes = 0\n\n        while fire_cells:\n            fire_value, i, j = heapq.heappop(fire_cells)\n            for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\n                if 0 <= x < m and 0 <= y < n and not visited[x][y]:\n                    visited[x][y] = 1\n                    if (x, y) == (m-1, n-1):\n                        return min_minutes + 1\n                    heapq.heappush(fire_cells, (fire_value+1, x, y))\n            min_minutes += 1\n\n        return -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2246", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestPath(self, parent: List[int], s: str) -> int:\n        n = len(parent)\n        depth = [0] * n\n        dp = [0] * n\n        child = [[] for _ in range(n)]\n        \n        for i in range(1, n):\n            p = parent[i]\n            child[p].append(i)\n            depth[i] = depth[p] + 1\n        \n        def dfs(node):\n            for child_node in child[node]:\n                dp[child_node] = max(dp[child_node], dp[node] + (s[node] != s[child_node]))\n                dfs(child_node)\n        \n        dp[0] = depth[0]\n        dfs(0)\n        return max(dp)\n```\n\nThis solution uses depth-first search (DFS) to traverse the tree and dynamic programming (DP) to store the longest path for each node. The DP array `dp` stores the longest path that ends at each node, and the `depth` array stores the depth of each node. The `child` array stores the children of each node.\n\nThe `dfs` function is a recursive function that traverses the tree in a depth-first manner. For each node, it updates the `dp` array with the maximum of its current value and the value of the parent node plus one if the characters of the parent and child nodes are different. Then, it recursively calls `dfs` for each child node.\n\nFinally, the function returns the maximum value in the `dp` array, which represents the length of the longest path in the tree where no pair of adjacent nodes have the same character assigned to them.", "extracted_code": "\nclass Solution:\n    def longestPath(self, parent: List[int], s: str) -> int:\n        n = len(parent)\n        depth = [0] * n\n        dp = [0] * n\n        child = [[] for _ in range(n)]\n        \n        for i in range(1, n):\n            p = parent[i]\n            child[p].append(i)\n            depth[i] = depth[p] + 1\n        \n        def dfs(node):\n            for child_node in child[node]:\n                dp[child_node] = max(dp[child_node], dp[node] + (s[node] != s[child_node]))\n                dfs(child_node)\n        \n        dp[0] = depth[0]\n        dfs(0)\n        return max(dp)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2242", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nimport itertools\nimport heapq\n\nclass Solution:\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n        n = len(scores)\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        visited = [False] * n\n        max_score = float('-inf')\n        for seq in itertools.permutations(range(n), 4):\n            if seq[0] in graph[seq[1]] and seq[1] in graph[seq[2]] and seq[2] in graph[seq[3]]:\n                score = sum(scores[i] for i in seq)\n                max_score = max(max_score, score)\n        return max_score if max_score != float('-inf') else -1\n```\n\nThis solution works by generating all possible permutations of length 4 and checking if there is an edge between adjacent nodes in the permutation. If there is, it calculates the sum of the scores of the nodes in the permutation and updates the maximum score if the current score is greater. If no valid permutation is found, it returns -1.\n\nThe time complexity is O(n!) due to generating all permutations, and the space complexity is O(n) for storing the graph and the visited array.", "extracted_code": "\nimport itertools\nimport heapq\n\nclass Solution:\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n        n = len(scores)\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        visited = [False] * n\n        max_score = float('-inf')\n        for seq in itertools.permutations(range(n), 4):\n            if seq[0] in graph[seq[1]] and seq[1] in graph[seq[2]] and seq[2] in graph[seq[3]]:\n                score = sum(scores[i] for i in seq)\n                max_score = max(max_score, score)\n        return max_score if max_score != float('-inf') else -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2812", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        thieves = [(i, j) for i in range(n) for j in range(n) if grid[i][j] == 1]\n        dist = [[np.inf]*n for _ in range(n)]\n        for i, j in thieves:\n            for x, y in thieves:\n                if i != x or j != y:\n                    dist[i][j] = min(dist[i][j], abs(i - x) + abs(j - y))\n        return max(dist[n - 1][n - 1])\n```\n\nThis function works by first finding all the thieves in the grid and storing their positions. Then, for each thief, it calculates the Manhattan distance to all other cells in the grid and stores the minimum distance in a distance matrix. Finally, it returns the maximum value in the last row and column of the distance matrix, which represents the maximum safeness factor of all paths leading to cell (n - 1, n - 1).", "extracted_code": "\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        thieves = [(i, j) for i in range(n) for j in range(n) if grid[i][j] == 1]\n        dist = [[np.inf]*n for _ in range(n)]\n        for i, j in thieves:\n            for x, y in thieves:\n                if i != x or j != y:\n                    dist[i][j] = min(dist[i][j], abs(i - x) + abs(j - y))\n        return max(dist[n - 1][n - 1])\n", "difficulty": 2.0}
{"task_id": "LeetCode/2811", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def canSplitArray(self, nums: List[int], m: int) -> bool:\n        prefix_sum = [0] * (len(nums) + 1)\n        for i in range(len(nums)):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        for x in prefix_sum:\n            if x >= m:\n                m -= 1\n        return m == 0\n```", "extracted_code": "\nclass Solution:\n    def canSplitArray(self, nums: List[int], m: int) -> bool:\n        prefix_sum = [0] * (len(nums) + 1)\n        for i in range(len(nums)):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        for x in prefix_sum:\n            if x >= m:\n                m -= 1\n        return m == 0\n", "difficulty": 2.0}
{"task_id": "LeetCode/2808", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumSeconds(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 0\n        min_val = min(nums)\n        nums = [x - min_val for x in nums]\n        gcd = nums[0]\n        for i in range(1, n):\n            gcd = math.gcd(gcd, nums[i])\n        lcm = n * gcd\n        return lcm - 1\n```\n\nThis function works by first subtracting the minimum value in the array from all elements, to ensure that the minimum value is 0. Then, it calculates the greatest common divisor (gcd) of all elements in the array. The time it takes to make all elements equal is equal to the least common multiple (lcm) of the elements, minus 1. The lcm is calculated as n * gcd, where n is the length of the array. The minus 1 is because the initial state of the array is not counted as a second.", "extracted_code": "\nclass Solution:\n    def minimumSeconds(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 0\n        min_val = min(nums)\n        nums = [x - min_val for x in nums]\n        gcd = nums[0]\n        for i in range(1, n):\n            gcd = math.gcd(gcd, nums[i])\n        lcm = n * gcd\n        return lcm - 1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2807", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(0, head)\n        prev, curr = dummy, head\n        while curr and curr.next:\n            gcd = math.gcd(curr.val, curr.next.val)\n            prev.next = ListNode(gcd, curr.next)\n            prev = prev.next\n            curr = curr.next\n        return dummy.next\n```", "extracted_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(0, head)\n        prev, curr = dummy, head\n        while curr and curr.next:\n            gcd = math.gcd(curr.val, curr.next.val)\n            prev.next = ListNode(gcd, curr.next)\n            prev = prev.next\n            curr = curr.next\n        return dummy.next\n", "difficulty": 2.0}
{"task_id": "LeetCode/2800", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumString(self, a: str, b: str, c: str) -> str:\n        # Find the minimum length among a, b, and c\n        min_len = min(len(a), len(b), len(c))\n        \n        # Initialize the result with the minimum length string\n        result = a if len(a) == min_len else (b if len(b) == min_len else c)\n        \n        # Iterate over the possible positions for the other two strings\n        for i in range(len(result) - min_len + 1):\n            for j in range(i + min_len, len(result) - min_len + 1):\n                # Check if the other two strings can be inserted at the current positions\n                if all(s in result[i:i+min_len] for s in (a, b, c)):\n                    result = result[i:i+min_len]\n                    break\n                if all(s in result[j:j+min_len] for s in (a, b, c)):\n                    result = result[j:j+min_len]\n                    break\n        \n        return result\n```", "extracted_code": "\nclass Solution:\n    def minimumString(self, a: str, b: str, c: str) -> str:\n        # Find the minimum length among a, b, and c\n        min_len = min(len(a), len(b), len(c))\n        \n        # Initialize the result with the minimum length string\n        result = a if len(a) == min_len else (b if len(b) == min_len else c)\n        \n        # Iterate over the possible positions for the other two strings\n        for i in range(len(result) - min_len + 1):\n            for j in range(i + min_len, len(result) - min_len + 1):\n                # Check if the other two strings can be inserted at the current positions\n                if all(s in result[i:i+min_len] for s in (a, b, c)):\n                    result = result[i:i+min_len]\n                    break\n                if all(s in result[j:j+min_len] for s in (a, b, c)):\n                    result = result[j:j+min_len]\n                    break\n        \n        return result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2799", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countCompleteSubarrays(self, nums: List[int]) -> int:\n        n = len(nums)\n        distinct_nums = set(nums)\n        count = 0\n        left = 0\n        right = 0\n        current_distinct = set()\n\n        while right < n:\n            if nums[right] not in current_distinct:\n                current_distinct.add(nums[right])\n                if len(current_distinct) == len(distinct_nums):\n                    count += (right - left + 1)\n                left += 1\n            else:\n                current_distinct.remove(nums[left])\n                left += 1\n            right += 1\n\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countCompleteSubarrays(self, nums: List[int]) -> int:\n        n = len(nums)\n        distinct_nums = set(nums)\n        count = 0\n        left = 0\n        right = 0\n        current_distinct = set()\n\n        while right < n:\n            if nums[right] not in current_distinct:\n                current_distinct.add(nums[right])\n                if len(current_distinct) == len(distinct_nums):\n                    count += (right - left + 1)\n                left += 1\n            else:\n                current_distinct.remove(nums[left])\n                left += 1\n            right += 1\n\n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2787", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfWays(self, n: int, x: int) -> int:\n        MOD = 10**9 + 7\n        dp = [[0]*(n+1) for _ in range(x+1)]\n        dp[0][0] = 1\n        for i in range(1, x+1):\n            for j in range(1, n+1):\n                dp[i][j] = dp[i][j-1]\n                if j >= i**(i-1):\n                    dp[i][j] += dp[i-1][j-i**(i-1)]\n                dp[i][j] %= MOD\n        return dp[x][n]\n```", "extracted_code": "\nclass Solution:\n    def numberOfWays(self, n: int, x: int) -> int:\n        MOD = 10**9 + 7\n        dp = [[0]*(n+1) for _ in range(x+1)]\n        dp[0][0] = 1\n        for i in range(1, x+1):\n            for j in range(1, n+1):\n                dp[i][j] = dp[i][j-1]\n                if j >= i**(i-1):\n                    dp[i][j] += dp[i-1][j-i**(i-1)]\n                dp[i][j] %= MOD\n        return dp[x][n]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2785", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sortVowels(self, s: str) -> str:\n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        vowel_indices = {i: c for i, c in enumerate(s) if c in vowels}\n        sorted_vowels = sorted(vowel_indices.values(), key=lambda c: ord(c.lower()))\n        for i, c in vowel_indices.items():\n            s = s[:i] + sorted_vowels.pop(0) + s[i+1:]\n        return s\n```\n\nThis function works by first creating a dictionary `vowel_indices` where the keys are the indices of the vowels in the string `s` and the values are the vowels themselves. The vowels are sorted in nondecreasing order of their ASCII values, and then the sorted vowels are inserted back into the string `s` at their original indices. The consonants remain in their original places because they are not modified.", "extracted_code": "\nclass Solution:\n    def sortVowels(self, s: str) -> str:\n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        vowel_indices = {i: c for i, c in enumerate(s) if c in vowels}\n        sorted_vowels = sorted(vowel_indices.values(), key=lambda c: ord(c.lower()))\n        for i, c in vowel_indices.items():\n            s = s[:i] + sorted_vowels.pop(0) + s[i+1:]\n        return s\n", "difficulty": 2.0}
{"task_id": "LeetCode/2772", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def checkArray(self, nums: List[int], k: int) -> bool:\n        while min(nums) > 0:\n            for i in range(len(nums) - k + 1):\n                if min(nums[i:i+k]) > 0:\n                    nums[i:i+k] = [x - 1 for x in nums[i:i+k]]\n        return min(nums) == 0\n```\n\nThis function works by iteratively applying the operation on the array until all elements become 0. The operation is applied on the subarrays of size `k` where the minimum element is greater than 0. If there is no such subarray, it means all elements are 0 and the function returns True. If no subarray can make all elements 0, the function returns False.", "extracted_code": "\nclass Solution:\n    def checkArray(self, nums: List[int], k: int) -> bool:\n        while min(nums) > 0:\n            for i in range(len(nums) - k + 1):\n                if min(nums[i:i+k]) > 0:\n                    nums[i:i+k] = [x - 1 for x in nums[i:i+k]]\n        return min(nums) == 0\n", "difficulty": 2.0}
{"task_id": "LeetCode/2771", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        nums3 = [max(nums1[i], nums2[i]) for i in range(n)]\n        longest_length = 1\n        current_length = 1\n        for i in range(1, n):\n            if nums3[i] >= nums3[i - 1]:\n                current_length += 1\n            else:\n                longest_length = max(longest_length, current_length)\n                current_length = 1\n        return max(longest_length, current_length)\n```\n\nThis function first creates a new list `nums3` by selecting the maximum value between the corresponding elements of `nums1` and `nums2`. Then, it iterates through `nums3` to find the longest non-decreasing subarray. It keeps track of the current length of the subarray and the maximum length found so far, updating them as it encounters increasing or non-increasing sequences. Finally, it returns the maximum length found.", "extracted_code": "\nclass Solution:\n    def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        nums3 = [max(nums1[i], nums2[i]) for i in range(n)]\n        longest_length = 1\n        current_length = 1\n        for i in range(1, n):\n            if nums3[i] >= nums3[i - 1]:\n                current_length += 1\n            else:\n                longest_length = max(longest_length, current_length)\n                current_length = 1\n        return max(longest_length, current_length)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2770", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\n\nclass Solution:\n    def maximumJumps(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        dp = [0] * n\n        stack = []\n        \n        for i in range(n):\n            while stack:\n                if nums[i] - nums[stack[-1]] <= target and nums[i] - nums[stack[-1]] >= -target:\n                    dp[i] = max(dp[i], dp[stack.pop()] + 1)\n                else:\n                    break\n            stack.append(i)\n        \n        return dp[-1] if dp[-1] > 0 else -1\n```", "extracted_code": "\nfrom typing import List\n\nclass Solution:\n    def maximumJumps(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        dp = [0] * n\n        stack = []\n        \n        for i in range(n):\n            while stack:\n                if nums[i] - nums[stack[-1]] <= target and nums[i] - nums[stack[-1]] >= -target:\n                    dp[i] = max(dp[i], dp[stack.pop()] + 1)\n                else:\n                    break\n            stack.append(i)\n        \n        return dp[-1] if dp[-1] > 0 else -1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2768", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countBlackBlocks(self, m: int, n: int, coordinates: List[List[int]]) -> List[int]:\n        grid = [[0]*(n+1) for _ in range(m+1)]\n        for x, y in coordinates:\n            grid[x][y] = 1\n        res = [0]*5\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    if grid[i+1][j] == 1 and grid[i][j+1] == 1 and grid[i+1][j+1] == 1:\n                        res[4] += 1\n                    elif grid[i+1][j] == 1 and grid[i][j+1] == 1:\n                        res[2] += 1\n                    elif grid[i+1][j] == 1:\n                        res[1] += 1\n                    elif grid[i][j+1] == 1:\n                        res[1] += 1\n                    else:\n                        res[0] += 1\n        return res\n```\n\nThis function first initializes a grid of size (m+1)x(n+1) with all elements as 0. Then it iterates over the coordinates and sets the corresponding cell in the grid to 1 if it is black. After that, it iterates over the grid and checks the number of black cells in each 2x2 block. It increments the corresponding count in the result array based on the number of black cells. Finally, it returns the result array.", "extracted_code": "\nclass Solution:\n    def countBlackBlocks(self, m: int, n: int, coordinates: List[List[int]]) -> List[int]:\n        grid = [[0]*(n+1) for _ in range(m+1)]\n        for x, y in coordinates:\n            grid[x][y] = 1\n        res = [0]*5\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    if grid[i+1][j] == 1 and grid[i][j+1] == 1 and grid[i+1][j+1] == 1:\n                        res[4] += 1\n                    elif grid[i+1][j] == 1 and grid[i][j+1] == 1:\n                        res[2] += 1\n                    elif grid[i+1][j] == 1:\n                        res[1] += 1\n                    elif grid[i][j+1] == 1:\n                        res[1] += 1\n                    else:\n                        res[0] += 1\n        return res\n", "difficulty": 2.0}
{"task_id": "LeetCode/2762", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def continuousSubarrays(self, nums: List[int]) -> int:\n        n = len(nums)\n        total = 0\n        for i in range(n):\n            for j in range(i, n):\n                if max(nums[i:j+1]) - min(nums[i:j+1]) <= 2:\n                    total += 1\n        return total\n```\n\nThis function works by iterating over all possible subarrays of `nums` and checking if the difference between the maximum and minimum values in the subarray is less than or equal to 2. If it is, the subarray is continuous and we increment `total`. The function finally returns `total`, which represents the total number of continuous subarrays.", "extracted_code": "\nclass Solution:\n    def continuousSubarrays(self, nums: List[int]) -> int:\n        n = len(nums)\n        total = 0\n        for i in range(n):\n            for j in range(i, n):\n                if max(nums[i:j+1]) - min(nums[i:j+1]) <= 2:\n                    total += 1\n        return total\n", "difficulty": 2.0}
{"task_id": "LeetCode/2750", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        ones_count = 0\n        good_splits = 0\n\n        for i in range(n):\n            if nums[i] == 1:\n                ones_count += 1\n            prefix_sum[i + 1] = ones_count\n\n        for i in range(n):\n            if nums[i] == 0:\n                good_splits += prefix_sum[i]\n                good_splits %= MOD\n\n        return good_splits\n```", "extracted_code": "\nclass Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        ones_count = 0\n        good_splits = 0\n\n        for i in range(n):\n            if nums[i] == 1:\n                ones_count += 1\n            prefix_sum[i + 1] = ones_count\n\n        for i in range(n):\n            if nums[i] == 0:\n                good_splits += prefix_sum[i]\n                good_splits %= MOD\n\n        return good_splits\n", "difficulty": 2.0}
{"task_id": "LeetCode/2251", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def fullBloomFlowers(self, flowers: List[List[int]], people: List[int]) -> List[int]:\n        flower_times = [(start, 1) for start, end in flowers] + [(end, -1) for start, end in flowers]\n        flower_times.sort()\n        current_flowers, result = 0, []\n        for time, change in flower_times:\n            current_flowers += change\n            if current_flowers > len(result):\n                result.append(time)\n        return result\n```", "extracted_code": "\nclass Solution:\n    def fullBloomFlowers(self, flowers: List[List[int]], people: List[int]) -> List[int]:\n        flower_times = [(start, 1) for start, end in flowers] + [(end, -1) for start, end in flowers]\n        flower_times.sort()\n        current_flowers, result = 0, []\n        for time, change in flower_times:\n            current_flowers += change\n            if current_flowers > len(result):\n                result.append(time)\n        return result\n", "difficulty": 3.0}
{"task_id": "LeetCode/2234", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\n        incomplete = [i for i in range(len(flowers)) if flowers[i] < target]\n        incomplete.sort(key=lambda i: flowers[i])\n        total_beauty = 0\n        complete_gardens = 0\n        for i in incomplete:\n            if newFlowers == 0:\n                break\n            to_plant = min(newFlowers, target - flowers[i])\n            newFlowers -= to_plant\n            flowers[i] += to_plant\n            if flowers[i] >= target:\n                complete_gardens += 1\n        total_beauty += complete_gardens * full\n        if incomplete:\n            total_beauty += min(flowers[i] for i in incomplete) * partial\n        return total_beauty\n```", "extracted_code": "\nclass Solution:\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\n        incomplete = [i for i in range(len(flowers)) if flowers[i] < target]\n        incomplete.sort(key=lambda i: flowers[i])\n        total_beauty = 0\n        complete_gardens = 0\n        for i in incomplete:\n            if newFlowers == 0:\n                break\n            to_plant = min(newFlowers, target - flowers[i])\n            newFlowers -= to_plant\n            flowers[i] += to_plant\n            if flowers[i] >= target:\n                complete_gardens += 1\n        total_beauty += complete_gardens * full\n        if incomplete:\n            total_beauty += min(flowers[i] for i in incomplete) * partial\n        return total_beauty\n", "difficulty": 3.0}
{"task_id": "LeetCode/2223", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sumScores(self, s: str) -> int:\n        n = len(s)\n        score = 0\n        for i in range(n):\n            score += min(i + 1, n - i)\n        return score\n```", "extracted_code": "\nclass Solution:\n    def sumScores(self, s: str) -> int:\n        n = len(s)\n        score = 0\n        for i in range(n):\n            score += min(i + 1, n - i)\n        return score\n", "difficulty": 3.0}
{"task_id": "LeetCode/2766", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n        marbles = collections.defaultdict(int)\n        for pos in nums:\n            marbles[pos] += 1\n        for i in range(len(moveFrom)):\n            marbles[moveTo[i]] += marbles[moveFrom[i]]\n            marbles[moveFrom[i]] = 0\n        return sorted(pos for pos, count in marbles.items() if count > 0)\n```", "extracted_code": "\nclass Solution:\n    def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n        marbles = collections.defaultdict(int)\n        for pos in nums:\n            marbles[pos] += 1\n        for i in range(len(moveFrom)):\n            marbles[moveTo[i]] += marbles[moveFrom[i]]\n            marbles[moveFrom[i]] = 0\n        return sorted(pos for pos, count in marbles.items() if count > 0)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2749", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\n        if num1 == 0:\n            return 0\n        if num1 < 0:\n            return -1\n        res = 0\n        for i in range(60, -1, -1):\n            if num1 >= 2**i + num2:\n                num1 -= 2**i + num2\n                res += 1\n            else:\n                break\n        if num1 == 0:\n            return res\n        else:\n            return -1\n```", "extracted_code": "\nclass Solution:\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\n        if num1 == 0:\n            return 0\n        if num1 < 0:\n            return -1\n        res = 0\n        for i in range(60, -1, -1):\n            if num1 >= 2**i + num2:\n                num1 -= 2**i + num2\n                res += 1\n            else:\n                break\n        if num1 == 0:\n            return res\n        else:\n            return -1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2747", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n        server_logs = [0] * (n + 1)\n        for log in logs:\n            server_logs[log[0]] += 1\n        res = []\n        for q in queries:\n            active_servers = sum(server_logs[i] > 0 for i in range(1, n + 1))\n            inactive_servers = n - active_servers\n            res.append(inactive_servers)\n        return res\n```", "extracted_code": "\nclass Solution:\n    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n        server_logs = [0] * (n + 1)\n        for log in logs:\n            server_logs[log[0]] += 1\n        res = []\n        for q in queries:\n            active_servers = sum(server_logs[i] > 0 for i in range(1, n + 1))\n            inactive_servers = n - active_servers\n            res.append(inactive_servers)\n        return res\n", "difficulty": 2.0}
{"task_id": "LeetCode/2734", "status": "ERROR", "reward": 0, "done": "Complete.", "raw_completion": "```python\nclass Solution:\n    def smallestString(self, s: str) -> str:\n        return ''.join(chr((ord(c) - ord('a') - 1) % 26 + ord('a')) for c in s)\n```", "extracted_code": "\nclass Solution:\n    def smallestString(self, s: str) -> str:\n        return ''.join(chr((ord(c) - ord('a') - 1) % 26 + ord('a')) for c in s)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2730", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\n        n = len(s)\n        max_len = 0\n        for i in range(n):\n            for j in range(i+2, n):\n                if s[i:j] == s[j:j+j-i] and len(s[i:j]) % 2 == 0:\n                    max_len = max(max_len, len(s[i:j]))\n        return max_len\n```", "extracted_code": "\nclass Solution:\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\n        n = len(s)\n        max_len = 0\n        for i in range(n):\n            for j in range(i+2, n):\n                if s[i:j] == s[j:j+j-i] and len(s[i:j]) % 2 == 0:\n                    max_len = max(max_len, len(s[i:j]))\n        return max_len\n", "difficulty": 2.0}
{"task_id": "LeetCode/2712", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumCost(self, s: str) -> int:\n        n = len(s)\n        cost = 0\n        ones = 0\n        for i in range(n):\n            if s[i] == '1':\n                ones += 1\n        zeros = n - ones\n        for i in range(n):\n            if s[i] == '1':\n                cost += min(ones, zeros)\n                ones -= 1\n            else:\n                cost += min(ones, zeros)\n                zeros -= 1\n        return cost\n```", "extracted_code": "\nclass Solution:\n    def minimumCost(self, s: str) -> int:\n        n = len(s)\n        cost = 0\n        ones = 0\n        for i in range(n):\n            if s[i] == '1':\n                ones += 1\n        zeros = n - ones\n        for i in range(n):\n            if s[i] == '1':\n                cost += min(ones, zeros)\n                ones -= 1\n            else:\n                cost += min(ones, zeros)\n                zeros -= 1\n        return cost\n", "difficulty": 2.0}
{"task_id": "LeetCode/2708", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        nums.sort()\n        return max(nums[i] * nums[i+1] * nums[-1] for i in range(len(nums)-2))\n```", "extracted_code": "\nclass Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        nums.sort()\n        return max(nums[i] * nums[i+1] * nums[-1] for i in range(len(nums)-2))\n", "difficulty": 2.0}
{"task_id": "LeetCode/2707", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\n        # Sort the dictionary in descending order of length\n        dictionary.sort(key=len, reverse=True)\n        \n        # Initialize the result\n        extra_char = 0\n        \n        # Iterate over the sorted dictionary\n        for word in dictionary:\n            # Find the index of the word in the string\n            index = s.find(word)\n            \n            # If the word is not found in the string\n            if index == -1:\n                # Add the length of the word to the extra characters\n                extra_char += len(word)\n            else:\n                # Remove the found word from the string\n                s = s[:index] + s[index+len(word):]\n        \n        # Return the extra characters\n        return extra_char\n```", "extracted_code": "\nclass Solution:\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\n        # Sort the dictionary in descending order of length\n        dictionary.sort(key=len, reverse=True)\n        \n        # Initialize the result\n        extra_char = 0\n        \n        # Iterate over the sorted dictionary\n        for word in dictionary:\n            # Find the index of the word in the string\n            index = s.find(word)\n            \n            # If the word is not found in the string\n            if index == -1:\n                # Add the length of the word to the extra characters\n                extra_char += len(word)\n            else:\n                # Remove the found word from the string\n                s = s[:index] + s[index+len(word):]\n        \n        # Return the extra characters\n        return extra_char\n", "difficulty": 2.0}
{"task_id": "LeetCode/2698", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def punishmentNumber(self, n: int) -> int:\n        punishment_sum = 0\n        for i in range(1, n+1):\n            square = i * i\n            square_str = str(square)\n            substrings = [int(square_str[j:k]) for j in range(len(square_str)) for k in range(j+1, len(square_str)+1)]\n            if i in substrings:\n                punishment_sum += square\n        return punishment_sum\n```", "extracted_code": "\nclass Solution:\n    def punishmentNumber(self, n: int) -> int:\n        punishment_sum = 0\n        for i in range(1, n+1):\n            square = i * i\n            square_str = str(square)\n            substrings = [int(square_str[j:k]) for j in range(len(square_str)) for k in range(j+1, len(square_str)+1)]\n            if i in substrings:\n                punishment_sum += square\n        return punishment_sum\n", "difficulty": 2.0}
{"task_id": "LeetCode/2680", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumOr(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        nums.sort()\n        for i in range(n):\n            if k > 0 and nums[i] < (1 << 16):\n                nums[i] *= 2\n                k -= 1\n        return sum(nums)\n```\n\nThis function works by first sorting the input array `nums`. Then, it iterates over the sorted array and multiplies each element by 2 if `k` is greater than 0 and the element is less than 2^16. This is because the maximum possible value of `nums[i] | nums[j]` for `i != j` is less than 2^16. After performing the operation on an element, it decrements `k`. Finally, it returns the sum of all elements in the array.\n\nThe time complexity of this function is O(n log n) due to the sorting operation, where n is the length of the input array. The space complexity is O(1) as it does not use any additional space.", "extracted_code": "\nclass Solution:\n    def maximumOr(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        nums.sort()\n        for i in range(n):\n            if k > 0 and nums[i] < (1 << 16):\n                nums[i] *= 2\n                k -= 1\n        return sum(nums)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2658", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        max_fish = 0\n        visited = [[0]*n for _ in range(m)]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def dfs(r, c):\n            nonlocal max_fish\n            max_fish = max(max_fish, grid[r][c])\n            visited[r][c] = 1\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc] and grid[nr][nc] > 0:\n                    dfs(nr, nc)\n\n        for r in range(m):\n            for c in range(n):\n                if grid[r][c] > 0 and not visited[r][c]:\n                    dfs(r, c)\n\n        return max_fish\n```", "extracted_code": "\nclass Solution:\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        max_fish = 0\n        visited = [[0]*n for _ in range(m)]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def dfs(r, c):\n            nonlocal max_fish\n            max_fish = max(max_fish, grid[r][c])\n            visited[r][c] = 1\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc] and grid[nr][nc] > 0:\n                    dfs(nr, nc)\n\n        for r in range(m):\n            for c in range(n):\n                if grid[r][c] > 0 and not visited[r][c]:\n                    dfs(r, c)\n\n        return max_fish\n", "difficulty": 2.0}
{"task_id": "LeetCode/2657", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\n        n = len(A)\n        C = [0] * n\n        common = set(A) & set(B)\n        for i in range(n):\n            C[i] = len(common & set(range(1, i+2)))\n        return C\n```", "extracted_code": "\nclass Solution:\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\n        n = len(A)\n        C = [0] * n\n        common = set(A) & set(B)\n        for i in range(n):\n            C[i] = len(common & set(range(1, i+2)))\n        return C\n", "difficulty": 2.0}
{"task_id": "LeetCode/2653", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\n\nclass Solution:\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\n        n = len(nums)\n        result = []\n        for i in range(n - k + 1):\n            subarray = nums[i:i + k]\n            negatives = sorted([num for num in subarray if num < 0])\n            if len(negatives) < x:\n                result.append(0)\n            else:\n                result.append(negatives[x - 1])\n        return result\n```", "extracted_code": "\nfrom typing import List\n\nclass Solution:\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\n        n = len(nums)\n        result = []\n        for i in range(n - k + 1):\n            subarray = nums[i:i + k]\n            negatives = sorted([num for num in subarray if num < 0])\n            if len(negatives) < x:\n                result.append(0)\n            else:\n                result.append(negatives[x - 1])\n        return result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2645", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def addMinimum(self, word: str) -> int:\n        count_a, count_b, count_c = 0, 0, 0\n        for char in word:\n            if char == 'a':\n                count_a += 1\n            elif char == 'b':\n                count_b += 1\n            else:\n                count_c += 1\n        \n        min_count = min(count_a, count_b, count_c)\n        return (count_a - min_count) + (count_b - min_count) + (count_c - min_count)\n```", "extracted_code": "\nclass Solution:\n    def addMinimum(self, word: str) -> int:\n        count_a, count_b, count_c = 0, 0, 0\n        for char in word:\n            if char == 'a':\n                count_a += 1\n            elif char == 'b':\n                count_b += 1\n            else:\n                count_c += 1\n        \n        min_count = min(count_a, count_b, count_c)\n        return (count_a - min_count) + (count_b - min_count) + (count_c - min_count)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2616", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def minimizeMax(self, nums: List[int], p: int) -> int:\n        nums = sorted(nums)\n        n = len(nums)\n        pairs = []\n        for i in range(p):\n            pairs.append((nums[i], nums[n-i-1]))\n        return min(max(abs(x-y) for x, y in pairs) for pairs in itertools.permutations(pairs, p))\n```\n\nThis function first sorts the input array in ascending order. Then it creates pairs of elements, one from the beginning and one from the end. It calculates the maximum difference for each pair and returns the minimum of these maximum differences. The pairs are generated in all possible permutations to ensure no index appears more than once amongst the p pairs.", "extracted_code": "\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def minimizeMax(self, nums: List[int], p: int) -> int:\n        nums = sorted(nums)\n        n = len(nums)\n        pairs = []\n        for i in range(p):\n            pairs.append((nums[i], nums[n-i-1]))\n        return min(max(abs(x-y) for x, y in pairs) for pairs in itertools.permutations(pairs, p))\n", "difficulty": 2.0}
{"task_id": "LeetCode/2615", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distance(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        arr = [0] * n\n        pos = {}\n        for i in range(n):\n            if nums[i] not in pos:\n                pos[nums[i]] = []\n            pos[nums[i]].append(i)\n        for num in pos:\n            indices = pos[num]\n            for i in range(len(indices)):\n                for j in range(i+1, len(indices)):\n                    arr[indices[i]] += abs(indices[i] - indices[j])\n                    arr[indices[j]] += abs(indices[i] - indices[j])\n        return arr\n```", "extracted_code": "\nclass Solution:\n    def distance(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        arr = [0] * n\n        pos = {}\n        for i in range(n):\n            if nums[i] not in pos:\n                pos[nums[i]] = []\n            pos[nums[i]].append(i)\n        for num in pos:\n            indices = pos[num]\n            for i in range(len(indices)):\n                for j in range(i+1, len(indices)):\n                    arr[indices[i]] += abs(indices[i] - indices[j])\n                    arr[indices[j]] += abs(indices[i] - indices[j])\n        return arr\n", "difficulty": 2.0}
{"task_id": "LeetCode/2601", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def primeSubOperation(self, nums: List[int]) -> bool:\n        def is_prime(n):\n            if n < 2:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        for i in range(len(nums)):\n            if i > 0 and nums[i] <= nums[i - 1]:\n                for j in range(i - 1, -1, -1):\n                    if nums[j] < nums[i] and is_prime(nums[i] - nums[j]):\n                        nums[i] -= nums[j]\n                        break\n                else:\n                    return False\n        return True\n```\n\nThis function checks if the array can be made strictly increasing by performing the given operation. It first defines a helper function `is_prime` to check if a number is prime. Then it iterates over the array and for each element, it checks if it is less than or equal to the previous element. If it is, it tries to find a previous element that is less than the current element and subtracts it if it is prime. If no such element is found, it returns False. If the loop completes without returning False, it means the array can be made strictly increasing and it returns True.", "extracted_code": "\nclass Solution:\n    def primeSubOperation(self, nums: List[int]) -> bool:\n        def is_prime(n):\n            if n < 2:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        for i in range(len(nums)):\n            if i > 0 and nums[i] <= nums[i - 1]:\n                for j in range(i - 1, -1, -1):\n                    if nums[j] < nums[i] and is_prime(nums[i] - nums[j]):\n                        nums[i] -= nums[j]\n                        break\n                else:\n                    return False\n        return True\n", "difficulty": 2.0}
{"task_id": "LeetCode/2576", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            dp[i] = 1\n            for j in range(i):\n                if nums[i] >= 2 * nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n```\n\nThis function first sorts the input array. Then it initializes a dynamic programming array `dp` with the same length as the input array. The `dp[i]` represents the maximum possible number of marked indices using the operation up to index `i`.\n\nThe function then iterates over the sorted array. For each index `i`, it initializes `dp[i]` to 1 (because an index can always be marked by itself). Then it iterates over all indices `j` less than `i`. If `nums[i]` is greater than or equal to twice `nums[j]`, it updates `dp[i]` to the maximum of its current value and `dp[j] + 1`.\n\nFinally, the function returns the maximum value in the `dp` array, which represents the maximum possible number of marked indices using the operation any number of times.", "extracted_code": "\nclass Solution:\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            dp[i] = 1\n            for j in range(i):\n                if nums[i] >= 2 * nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2568", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minImpossibleOR(self, nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        result = 1\n        for num in nums:\n            if num > result:\n                break\n            while num > result:\n                result <<= 1\n        return result\n```\n\nThis function works by first sorting the input array. Then it initializes a variable `result` to 1, which will hold the minimum non-expressible positive integer. It iterates over the sorted array, and for each number, it checks if it is greater than `result`. If it is, it breaks the loop, because `result` is not expressible, so it can return `result`. If `result` is less than or equal to the current number, it means `result` can be expressed as the bitwise OR of some subsequence of `nums`, so it doubles `result` until it is greater than the current number. After the loop, it returns `result`, which is the minimum non-expressible positive integer.", "extracted_code": "\nclass Solution:\n    def minImpossibleOR(self, nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        result = 1\n        for num in nums:\n            if num > result:\n                break\n            while num > result:\n                result <<= 1\n        return result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2564", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\n        n = len(s)\n        prefix_xor = [0] * (n + 1)\n        for i in range(n):\n            prefix_xor[i + 1] = prefix_xor[i] ^ int(s[i])\n\n        ans = []\n        for first, second in queries:\n            right = -1\n            for i in range(first, n + 1):\n                if prefix_xor[i] == second:\n                    right = i - 1\n                    break\n            if right == -1:\n                ans.append([-1, -1])\n            else:\n                ans.append([first, right])\n\n        return ans\n```", "extracted_code": "\nclass Solution:\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\n        n = len(s)\n        prefix_xor = [0] * (n + 1)\n        for i in range(n):\n            prefix_xor[i + 1] = prefix_xor[i] ^ int(s[i])\n\n        ans = []\n        for first, second in queries:\n            right = -1\n            for i in range(first, n + 1):\n                if prefix_xor[i] == second:\n                    right = i - 1\n                    break\n            if right == -1:\n                ans.append([-1, -1])\n            else:\n                ans.append([first, right])\n\n        return ans\n", "difficulty": 2.0}
{"task_id": "LeetCode/2563", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\n\nclass Solution:\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        res = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                total = prefix_sum[j + 1] - prefix_sum[i]\n                if lower <= total <= upper:\n                    res += 1\n        return res\n```\n\nThis function works by first calculating the prefix sum of the input array `nums`. Then, it iterates over all pairs `(i, j)` where `i < j`. For each pair, it calculates the sum of the elements in the range `[i, j)` and checks if it falls within the range `[lower, upper]`. If it does, it increments the result counter `res`. Finally, it returns `res` as the number of fair pairs.", "extracted_code": "\nfrom typing import List\n\nclass Solution:\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        res = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                total = prefix_sum[j + 1] - prefix_sum[i]\n                if lower <= total <= upper:\n                    res += 1\n        return res\n", "difficulty": 2.0}
{"task_id": "LeetCode/2560", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minCapability(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        if k == 1:\n            return min(nums)\n        if k == n:\n            return max(nums)\n        dp = [0] * (n + 2)\n        dp[1] = nums[0]\n        dp[2] = max(nums[0], nums[1])\n        for i in range(3, n + 1):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 1])\n        return min(dp[k:])\n```", "extracted_code": "\nclass Solution:\n    def minCapability(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        if k == 1:\n            return min(nums)\n        if k == n:\n            return max(nums)\n        dp = [0] * (n + 2)\n        dp[1] = nums[0]\n        dp[2] = max(nums[0], nums[1])\n        for i in range(3, n + 1):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 1])\n        return min(dp[k:])\n", "difficulty": 2.0}
{"task_id": "LeetCode/2550", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def monkeyMove(self, n: int) -> int:\n        MOD = 10**9 + 7\n        # For a convex polygon with n vertices, the number of ways the monkeys can move\n        # so that at least one collision happens is equal to the number of ways the\n        # monkeys can move so that no collision happens, which is (n-1) choose (n-2).\n        # Since there are n-1 edges and each edge can be traversed in 2 directions,\n        # the total number of ways is 2 * (n-1) choose (n-2).\n        # However, since we want at least one collision, we subtract the number of ways\n        # the monkeys can move so that no collision happens from the total number of ways.\n        return (2 * comb(n-1, n-2, MOD)) % MOD\n\n# Function to calculate combinations using Pascal's triangle\ndef comb(n: int, k: int, MOD: int) -> int:\n    c = [1] * (k+1)\n    for i in range(1, n+1):\n        for j in range(min(i, k), 0, -1):\n            c[j] = (c[j] + c[j-1]) % MOD\n    return c[k]\n```\n\nThis function calculates the number of ways the monkeys can move so that at least one collision happens using the concept of combinations. The function comb calculates combinations using Pascal's triangle, which is a more efficient method than calculating factorials. The time complexity of this function is O(n), making it a highly efficient solution for large inputs.", "extracted_code": "\nclass Solution:\n    def monkeyMove(self, n: int) -> int:\n        MOD = 10**9 + 7\n        # For a convex polygon with n vertices, the number of ways the monkeys can move\n        # so that at least one collision happens is equal to the number of ways the\n        # monkeys can move so that no collision happens, which is (n-1) choose (n-2).\n        # Since there are n-1 edges and each edge can be traversed in 2 directions,\n        # the total number of ways is 2 * (n-1) choose (n-2).\n        # However, since we want at least one collision, we subtract the number of ways\n        # the monkeys can move so that no collision happens from the total number of ways.\n        return (2 * comb(n-1, n-2, MOD)) % MOD\n\n# Function to calculate combinations using Pascal's triangle\ndef comb(n: int, k: int, MOD: int) -> int:\n    c = [1] * (k+1)\n    for i in range(1, n+1):\n        for j in range(min(i, k), 0, -1):\n            c[j] = (c[j] + c[j-1]) % MOD\n    return c[k]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2640", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        ans = [0] * n\n        max_val = 0\n        for i in range(n):\n            max_val = max(max_val, nums[i])\n            ans[i] = max_val * (i + 1)\n        return ans\n```", "extracted_code": "\nclass Solution:\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        ans = [0] * n\n        max_val = 0\n        for i in range(n):\n            max_val = max(max_val, nums[i])\n            ans[i] = max_val * (i + 1)\n        return ans\n", "difficulty": 2.0}
{"task_id": "LeetCode/2592", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\n\nclass Solution:\n    def maximizeGreatness(self, nums: List[int]) -> int:\n        nums.sort(reverse=True)\n        n = len(nums)\n        return n * (n - 1) // 2\n```\n\nThis function works by first sorting the input array in descending order. Since we are allowed to permute the array, we can achieve the maximum greatness by placing the largest number at the end of the array and the smallest number at the beginning. This way, the largest number will be greater than all other numbers in the array except for itself.\n\nThe greatness is calculated as the number of indices for which `perm[i] > nums[i]`. Since the smallest number is at the beginning and the largest number is at the end, the greatness is equal to the number of indices between the smallest and largest numbers, excluding the largest number itself. This is calculated as `n * (n - 1) // 2`, where `n` is the length of the array.", "extracted_code": "\nfrom typing import List\n\nclass Solution:\n    def maximizeGreatness(self, nums: List[int]) -> int:\n        nums.sort(reverse=True)\n        n = len(nums)\n        return n * (n - 1) // 2\n", "difficulty": 2.0}
{"task_id": "LeetCode/2587", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxScore(self, nums: List[int]) -> int:\n        nums.sort()\n        prefix = [nums[0]]\n        for i in range(1, len(nums)):\n            prefix.append(prefix[i-1] + nums[i])\n        return sum(1 for x in prefix if x > 0)\n```\n\nThis function first sorts the input array `nums`. Then it calculates the prefix sums and counts the number of positive numbers in the prefix sum array. The score is the count of positive numbers in the prefix sum array. The function returns the maximum score.\n\nThe time complexity of this function is O(n log n) due to the sorting operation, where n is the length of the input array. The space complexity is O(n) for storing the prefix sum array.", "extracted_code": "\nclass Solution:\n    def maxScore(self, nums: List[int]) -> int:\n        nums.sort()\n        prefix = [nums[0]]\n        for i in range(1, len(nums)):\n            prefix.append(prefix[i-1] + nums[i])\n        return sum(1 for x in prefix if x > 0)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2579", "status": "Memory Limit Exceeded", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def coloredCells(self, n: int) -> int:\n        rows, cols = 2*n, 2*n\n        grid = [[0]*cols for _ in range(rows)]\n        grid[n][n] = 1\n        colored = {(n, n)}\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        \n        for _ in range(n-1):\n            new_colored = set()\n            for r, c in colored:\n                for dr, dc in directions:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0:\n                        grid[nr][nc] = 1\n                        new_colored.add((nr, nc))\n            colored = new_colored\n        \n        return sum(sum(row) for row in grid)\n```", "extracted_code": "\nclass Solution:\n    def coloredCells(self, n: int) -> int:\n        rows, cols = 2*n, 2*n\n        grid = [[0]*cols for _ in range(rows)]\n        grid[n][n] = 1\n        colored = {(n, n)}\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        \n        for _ in range(n-1):\n            new_colored = set()\n            for r, c in colored:\n                for dr, dc in directions:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0:\n                        grid[nr][nc] = 1\n                        new_colored.add((nr, nc))\n            colored = new_colored\n        \n        return sum(sum(row) for row in grid)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2556", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        visited = [[False]*n for _ in range(m)]\n        \n        def dfs(x, y):\n            if x == m-1 and y == n-1:\n                return True\n            visited[x][y] = True\n            for dx, dy in [(1, 0), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 1:\n                    if dfs(nx, ny):\n                        return True\n            return False\n        \n        if not dfs(0, 0):\n            return False\n        \n        for x in range(m):\n            for y in range(n):\n                if grid[x][y] == 1 and not visited[x][y]:\n                    grid[x][y] = 0\n                    if dfs(0, 0):\n                        return True\n                    grid[x][y] = 1\n        return False\n```\n\nThis function uses depth-first search (DFS) to check if there is a path from `(0, 0)` to `(m - 1, n - 1)` in the original grid. If there is no such path, it returns `False`. If there is a path, it iterates over all cells in the grid, flips the value of each cell that is not visited during the DFS, and checks if there is still a path from `(0, 0)` to `(m - 1, n - 1)` in the modified grid. If there is such a path for any cell, it returns `True`. If there is no such path for any cell, it returns `False`.", "extracted_code": "\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        visited = [[False]*n for _ in range(m)]\n        \n        def dfs(x, y):\n            if x == m-1 and y == n-1:\n                return True\n            visited[x][y] = True\n            for dx, dy in [(1, 0), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 1:\n                    if dfs(nx, ny):\n                        return True\n            return False\n        \n        if not dfs(0, 0):\n            return False\n        \n        for x in range(m):\n            for y in range(n):\n                if grid[x][y] == 1 and not visited[x][y]:\n                    grid[x][y] = 0\n                    if dfs(0, 0):\n                        return True\n                    grid[x][y] = 1\n        return False\n", "difficulty": 2.0}
{"task_id": "LeetCode/2555", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\n        n = len(prizePositions)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + prizePositions[i]\n\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for l in range(1, n + 1):\n            for i in range(n - l + 1):\n                j = i + l - 1\n                dp[i][j] = max(dp[i][j], prefix_sum[j + 1] - prefix_sum[i] + dp[i][j - 1])\n                if l >= k:\n                    dp[i][j] = max(dp[i][j], dp[i][j - k] + prefix_sum[j + 1] - prefix_sum[j - k + 1])\n                    dp[i][j] = max(dp[i][j], dp[i + k][j] + prefix_sum[j + 1] - prefix_sum[i])\n\n        return dp[0][n - 1]\n```\n\nThis function uses dynamic programming to find the maximum number of prizes that can be won. It first calculates the prefix sum of the prize positions. Then it initializes a 2D array dp where dp[i][j] represents the maximum number of prizes that can be won using the prize positions from i to j. It iterates through all possible subarrays of prize positions and updates dp[i][j] accordingly. If the length of the subarray is greater than or equal to k, it also considers the possibility of using two segments of length k. Finally, it returns dp[0][n - 1], which represents the maximum number of prizes that can be won using all the prize positions.", "extracted_code": "\nclass Solution:\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\n        n = len(prizePositions)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + prizePositions[i]\n\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for l in range(1, n + 1):\n            for i in range(n - l + 1):\n                j = i + l - 1\n                dp[i][j] = max(dp[i][j], prefix_sum[j + 1] - prefix_sum[i] + dp[i][j - 1])\n                if l >= k:\n                    dp[i][j] = max(dp[i][j], dp[i][j - k] + prefix_sum[j + 1] - prefix_sum[j - k + 1])\n                    dp[i][j] = max(dp[i][j], dp[i + k][j] + prefix_sum[j + 1] - prefix_sum[i])\n\n        return dp[0][n - 1]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2554", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\n        banned = set(banned)\n        dp = [0] * (maxSum + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            if i not in banned:\n                for j in range(maxSum, i - 1, -1):\n                    dp[j] = max(dp[j], dp[j - i] + 1)\n        return dp[maxSum]\n```\n\nThis function uses dynamic programming to solve the problem. The dp array stores the maximum number of integers that can be chosen with a sum less than or equal to j. For each integer i in the range from 1 to n, if it is not banned, we update the dp array by choosing i and adding 1 to the maximum number of integers that can be chosen with a sum less than j - i. The final result is dp[maxSum], which is the maximum number of integers that can be chosen with a sum less than or equal to maxSum.", "extracted_code": "\nclass Solution:\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\n        banned = set(banned)\n        dp = [0] * (maxSum + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            if i not in banned:\n                for j in range(maxSum, i - 1, -1):\n                    dp[j] = max(dp[j], dp[j - i] + 1)\n        return dp[maxSum]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2546", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeStringsEqual(self, s: str, target: str) -> bool:\n        if len(s) != len(target):\n            return False\n        if s == target:\n            return True\n        freq_s = [0]*26\n        freq_t = [0]*26\n        for i in range(len(s)):\n            freq_s[ord(s[i])-ord('a')] += 1\n            freq_t[ord(target[i])-ord('a')] += 1\n        for i in range(26):\n            if freq_s[i] != freq_t[i]:\n                return False\n        return True\n```\n\nThis function checks if two strings `s` and `target` can be made equal by performing the operations described. The function first checks if the lengths of the strings are equal and if they are the same. If they are, it returns True. If not, it creates two frequency arrays `freq_s` and `freq_t` for the characters in `s` and `target`, respectively. It then compares the frequency arrays. If they are equal, it returns True, otherwise it returns False.", "extracted_code": "\nclass Solution:\n    def makeStringsEqual(self, s: str, target: str) -> bool:\n        if len(s) != len(target):\n            return False\n        if s == target:\n            return True\n        freq_s = [0]*26\n        freq_t = [0]*26\n        for i in range(len(s)):\n            freq_s[ord(s[i])-ord('a')] += 1\n            freq_t[ord(target[i])-ord('a')] += 1\n        for i in range(26):\n            if freq_s[i] != freq_t[i]:\n                return False\n        return True\n", "difficulty": 2.0}
{"task_id": "LeetCode/2545", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sortTheStudents(self, score: List[List[int]], k: int) -> List[List[int]]:\n        return sorted(score, key=lambda x: -x[k])\n```", "extracted_code": "\nclass Solution:\n    def sortTheStudents(self, score: List[List[int]], k: int) -> List[List[int]]:\n        return sorted(score, key=lambda x: -x[k])\n", "difficulty": 2.0}
{"task_id": "LeetCode/2531", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isItPossible(self, word1: str, word2: str) -> bool:\n        word1_chars = set(word1)\n        word2_chars = set(word2)\n        return len(word1_chars) - len(word1) == len(word2_chars) - len(word2) == 1\n```\n\nThis function works by first converting each string into a set, which automatically removes duplicate characters. It then checks if the difference in lengths between the original strings and the sets is equal to 1. If it is, that means it's possible to get the number of distinct characters in both strings to be equal with exactly one move.", "extracted_code": "\nclass Solution:\n    def isItPossible(self, word1: str, word2: str) -> bool:\n        word1_chars = set(word1)\n        word2_chars = set(word2)\n        return len(word1_chars) - len(word1) == len(word2_chars) - len(word2) == 1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2523", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def closestPrimes(self, left: int, right: int) -> List[int]:\n        def is_prime(n):\n            if n < 2:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        primes = [i for i in range(left, right + 1) if is_prime(i)]\n        if len(primes) < 2:\n            return [-1, -1]\n        else:\n            min_diff = float('inf')\n            min_pair = None\n            for i in range(len(primes) - 1):\n                if primes[i + 1] - primes[i] < min_diff:\n                    min_diff = primes[i + 1] - primes[i]\n                    min_pair = (primes[i], primes[i + 1])\n            return list(min_pair)\n```", "extracted_code": "\nclass Solution:\n    def closestPrimes(self, left: int, right: int) -> List[int]:\n        def is_prime(n):\n            if n < 2:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        primes = [i for i in range(left, right + 1) if is_prime(i)]\n        if len(primes) < 2:\n            return [-1, -1]\n        else:\n            min_diff = float('inf')\n            min_pair = None\n            for i in range(len(primes) - 1):\n                if primes[i + 1] - primes[i] < min_diff:\n                    min_diff = primes[i + 1] - primes[i]\n                    min_pair = (primes[i], primes[i + 1])\n            return list(min_pair)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2521", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\n        product = 1\n        for num in nums:\n            product *= num\n        factors = set()\n        i = 2\n        while i * i <= product:\n            if product % i:\n                i += 1\n            else:\n                product //= i\n                factors.add(i)\n        if product > 1:\n            factors.add(product)\n        return len(factors)\n```", "extracted_code": "\nclass Solution:\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\n        product = 1\n        for num in nums:\n            product *= num\n        factors = set()\n        i = 2\n        while i * i <= product:\n            if product % i:\n                i += 1\n            else:\n                product //= i\n                factors.add(i)\n        if product > 1:\n            factors.add(product)\n        return len(factors)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2517", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        price.sort()\n        n = len(price)\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = min(dp[j] + price[i - 1] - price[j] for j in range(i - 1))\n        return max(dp[i] for i in range(k, n + 1))\n```\n\nThis function first sorts the price array. Then it initializes a dp array to keep track of the minimum tastiness for each basket size. For each basket size from 1 to n, it calculates the minimum tastiness by iterating over all possible combinations of candies in the basket and taking the minimum difference of their prices. Finally, it returns the maximum tastiness among all baskets of size k.", "extracted_code": "\nclass Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        price.sort()\n        n = len(price)\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = min(dp[j] + price[i - 1] - price[j] for j in range(i - 1))\n        return max(dp[i] for i in range(k, n + 1))\n", "difficulty": 2.0}
{"task_id": "LeetCode/2513", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        # Find the least common multiple (LCM) of divisor1 and divisor2\n        lcm = divisor1 * divisor2 // math.gcd(divisor1, divisor2)\n\n        # Calculate the maximum possible value for arr1 and arr2\n        max_val1 = (uniqueCnt1 * lcm) // divisor1\n        max_val2 = (uniqueCnt2 * lcm) // divisor2\n\n        # Return the minimum possible maximum value\n        return min(max_val1, max_val2)\n```\n\nThis function works by first calculating the least common multiple (LCM) of `divisor1` and `divisor2`. The LCM is the smallest positive integer that is divisible by both `divisor1` and `divisor2`.\n\nNext, it calculates the maximum possible value for `arr1` and `arr2` by multiplying the LCM by the number of unique integers required in each array and then dividing by the respective divisor. This is done because each integer in `arr1` and `arr2` must be a multiple of the LCM and must also be divisible by the respective divisor.\n\nFinally, it returns the minimum possible maximum value, which is the smallest of `max_val1` and `max_val2`. This is because the maximum value for either array cannot be larger than this minimum possible maximum value and still satisfy all the conditions.", "extracted_code": "\nclass Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        # Find the least common multiple (LCM) of divisor1 and divisor2\n        lcm = divisor1 * divisor2 // math.gcd(divisor1, divisor2)\n\n        # Calculate the maximum possible value for arr1 and arr2\n        max_val1 = (uniqueCnt1 * lcm) // divisor1\n        max_val2 = (uniqueCnt2 * lcm) // divisor2\n\n        # Return the minimum possible maximum value\n        return min(max_val1, max_val2)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2512", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\n        points = {}\n        for word in positive_feedback:\n            positive_feedback[word] = 3\n        for word in negative_feedback:\n            negative_feedback[word] = -1\n        for r, sid in zip(report, student_id):\n            score = 0\n            for word in r.split():\n                if word in positive_feedback:\n                    score += positive_feedback[word]\n                elif word in negative_feedback:\n                    score += negative_feedback[word]\n            if sid not in points or points[sid] < score:\n                points[sid] = score\n        top_k = sorted(points.items(), key=lambda x: (-x[1], x[0]))\n        return [sid for sid, score in top_k[:k]]\n```", "extracted_code": "\nclass Solution:\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\n        points = {}\n        for word in positive_feedback:\n            positive_feedback[word] = 3\n        for word in negative_feedback:\n            negative_feedback[word] = -1\n        for r, sid in zip(report, student_id):\n            score = 0\n            for word in r.split():\n                if word in positive_feedback:\n                    score += positive_feedback[word]\n                elif word in negative_feedback:\n                    score += negative_feedback[word]\n            if sid not in points or points[sid] < score:\n                points[sid] = score\n        top_k = sorted(points.items(), key=lambda x: (-x[1], x[0]))\n        return [sid for sid, score in top_k[:k]]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2482", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\n        m, n = len(grid), len(grid[0])\n        ones_rows, ones_cols = [0]*m, [0]*n\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    ones_rows[i] += 1\n                    ones_cols[j] += 1\n        return [[ones_rows[i] + ones_cols[j] - (m-ones_rows[i]) - (n-ones_cols[j]) for j in range(n)] for i in range(m)]\n```", "extracted_code": "\nclass Solution:\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\n        m, n = len(grid), len(grid[0])\n        ones_rows, ones_cols = [0]*m, [0]*n\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    ones_rows[i] += 1\n                    ones_cols[j] += 1\n        return [[ones_rows[i] + ones_cols[j] - (m-ones_rows[i]) - (n-ones_cols[j]) for j in range(n)] for i in range(m)]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2516", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def takeCharacters(self, s: str, k: int) -> int:\n        from collections import Counter\n        cnt = Counter(s)\n        left = [0] * 3\n        right = [0] * 3\n        for i in range(len(s)):\n            left[ord(s[i]) - ord('a')] += 1\n        for i in range(len(s) - 1, -1, -1):\n            right[ord(s[i]) - ord('a')] += 1\n        res = float('inf')\n        for i in range(3):\n            if cnt[chr(i + ord('a'))] < k:\n                return -1\n            res = min(res, i + 1 + (k - left[i]) + (k - right[i]))\n        return res\n```", "extracted_code": "\nclass Solution:\n    def takeCharacters(self, s: str, k: int) -> int:\n        from collections import Counter\n        cnt = Counter(s)\n        left = [0] * 3\n        right = [0] * 3\n        for i in range(len(s)):\n            left[ord(s[i]) - ord('a')] += 1\n        for i in range(len(s) - 1, -1, -1):\n            right[ord(s[i]) - ord('a')] += 1\n        res = float('inf')\n        for i in range(3):\n            if cnt[chr(i + ord('a'))] < k:\n                return -1\n            res = min(res, i + 1 + (k - left[i]) + (k - right[i]))\n        return res\n", "difficulty": 2.0}
{"task_id": "LeetCode/2507", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def smallestValue(self, n: int) -> int:\n        def prime_factors(n):\n            factors = []\n            i = 2\n            while i * i <= n:\n                if n % i:\n                    i += 1\n                else:\n                    n //= i\n                    factors.append(i)\n            if n > 1:\n                factors.append(n)\n            return factors\n\n        factors = prime_factors(n)\n        while len(factors) > 1:\n            n = sum(factors)\n            factors = prime_factors(n)\n\n        return n\n```", "extracted_code": "\nclass Solution:\n    def smallestValue(self, n: int) -> int:\n        def prime_factors(n):\n            factors = []\n            i = 2\n            while i * i <= n:\n                if n % i:\n                    i += 1\n                else:\n                    n //= i\n                    factors.append(i)\n            if n > 1:\n                factors.append(n)\n            return factors\n\n        factors = prime_factors(n)\n        while len(factors) > 1:\n            n = sum(factors)\n            factors = prime_factors(n)\n\n        return n\n", "difficulty": 2.0}
{"task_id": "LeetCode/2501", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestSquareStreak(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n < 2:\n            return -1\n        max_len = 1\n        cur_len = 1\n        for i in range(1, n):\n            if nums[i] == nums[i-1] ** 2:\n                cur_len += 1\n            else:\n                if cur_len > max_len:\n                    max_len = cur_len\n                cur_len = 1\n        if cur_len > max_len:\n            max_len = cur_len\n        return max_len if max_len > 1 else -1\n```", "extracted_code": "\nclass Solution:\n    def longestSquareStreak(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n < 2:\n            return -1\n        max_len = 1\n        cur_len = 1\n        for i in range(1, n):\n            if nums[i] == nums[i-1] ** 2:\n                cur_len += 1\n            else:\n                if cur_len > max_len:\n                    max_len = cur_len\n                cur_len = 1\n        if cur_len > max_len:\n            max_len = cur_len\n        return max_len if max_len > 1 else -1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2498", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxJump(self, stones: List[int]) -> int:\n        n = len(stones)\n        dp = [0] * n\n        dp[0] = stones[1] - stones[0]\n        for i in range(1, n - 1):\n            dp[i] = max(dp[i - 1], stones[i + 1] - stones[i])\n        return max(dp[-1], stones[-1] - stones[-2])\n```\n\nThis function works by iterating through the stones array and calculating the maximum jump length at each stone. The maximum jump length is determined by either jumping to the next stone or jumping to the stone after that. The function returns the maximum of the last two jumps, as the frog must return to the first stone after reaching the last stone.", "extracted_code": "\nclass Solution:\n    def maxJump(self, stones: List[int]) -> int:\n        n = len(stones)\n        dp = [0] * n\n        dp[0] = stones[1] - stones[0]\n        for i in range(1, n - 1):\n            dp[i] = max(dp[i - 1], stones[i + 1] - stones[i])\n        return max(dp[-1], stones[-1] - stones[-2])\n", "difficulty": 2.0}
{"task_id": "LeetCode/2497", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nimport heapq\n\nclass Solution:\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\n        graph = [[] for _ in range(len(vals))]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        visited = [0] * len(vals)\n\n        def dfs(node, parent):\n            visited[node] = 1\n            neighbors = [x for x in graph[node] if x != parent]\n            if len(neighbors) > k:\n                return -float('inf')\n            if not neighbors:\n                return vals[node]\n            return vals[node] + max(dfs(neighbor, node) for neighbor in neighbors)\n\n        return max(dfs(i, -1) for i in range(len(vals)) if not visited[i])\n```\n\nThis solution uses depth-first search (DFS) to explore all possible star graphs. It first constructs an adjacency list representation of the graph. Then, it defines a recursive function `dfs` that takes a node and its parent as input. The function marks the node as visited and finds all its neighbors. If the number of neighbors is greater than `k`, it returns negative infinity since it's impossible to form a valid star graph. If the node has no neighbors, it returns the value of the node. Otherwise, it returns the maximum sum of the node and its neighbors' values. The main function then returns the maximum star sum by exploring all unvisited nodes.", "extracted_code": "\nimport heapq\n\nclass Solution:\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\n        graph = [[] for _ in range(len(vals))]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        visited = [0] * len(vals)\n\n        def dfs(node, parent):\n            visited[node] = 1\n            neighbors = [x for x in graph[node] if x != parent]\n            if len(neighbors) > k:\n                return -float('inf')\n            if not neighbors:\n                return vals[node]\n            return vals[node] + max(dfs(neighbor, node) for neighbor in neighbors)\n\n        return max(dfs(i, -1) for i in range(len(vals)) if not visited[i])\n", "difficulty": 2.0}
{"task_id": "LeetCode/2487", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return None\n        max_val = head.val\n        new_head = ListNode(max_val)\n        current = new_head\n        while head:\n            if head.val >= max_val:\n                max_val = head.val\n                current.next = ListNode(max_val)\n                current = current.next\n            head = head.next\n        current.next = None\n        return new_head.next\n```", "extracted_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return None\n        max_val = head.val\n        new_head = ListNode(max_val)\n        current = new_head\n        while head:\n            if head.val >= max_val:\n                max_val = head.val\n                current.next = ListNode(max_val)\n                current = current.next\n            head = head.next\n        current.next = None\n        return new_head.next\n", "difficulty": 2.0}
{"task_id": "LeetCode/2483", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def bestClosingTime(self, customers: str) -> int:\n        n = len(customers)\n        min_penalty = float('inf')\n        penalty = [0, 0]\n        close_time = 0\n        for i in range(n):\n            penalty[i%2] += (customers[i] == 'N')\n            if i >= 1:\n                penalty[i%2] -= (customers[i-1] == 'Y')\n            if i >= 2:\n                min_penalty = min(min_penalty, penalty[(i-1)%2])\n        for i in range(n-1, -1, -1):\n            if penalty[i%2] == min_penalty:\n                close_time = i\n                break\n        return close_time\n```\n\nThis function calculates the penalty for each hour and finds the minimum penalty. It then iterates backward from the hour with the minimum penalty to find the earliest hour at which the shop must be closed to incur a minimum penalty.", "extracted_code": "\nclass Solution:\n    def bestClosingTime(self, customers: str) -> int:\n        n = len(customers)\n        min_penalty = float('inf')\n        penalty = [0, 0]\n        close_time = 0\n        for i in range(n):\n            penalty[i%2] += (customers[i] == 'N')\n            if i >= 1:\n                penalty[i%2] -= (customers[i-1] == 'Y')\n            if i >= 2:\n                min_penalty = min(min_penalty, penalty[(i-1)%2])\n        for i in range(n-1, -1, -1):\n            if penalty[i%2] == min_penalty:\n                close_time = i\n                break\n        return close_time\n", "difficulty": 2.0}
{"task_id": "LeetCode/2476", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\n        def inorder(node, arr):\n            if node:\n                inorder(node.left, arr)\n                arr.append(node.val)\n                inorder(node.right, arr)\n\n        def find_closest(arr, target):\n            left, right = -1, -1\n            for val in arr:\n                if val <= target:\n                    left = max(left, val)\n                elif val >= target:\n                    right = min(right, val) if right != -1 else val\n            return [left, right]\n\n        tree_values = []\n        inorder(root, tree_values)\n        tree_values = sorted(tree_values)\n\n        return [find_closest(tree_values, q) for q in queries]\n```", "extracted_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\n        def inorder(node, arr):\n            if node:\n                inorder(node.left, arr)\n                arr.append(node.val)\n                inorder(node.right, arr)\n\n        def find_closest(arr, target):\n            left, right = -1, -1\n            for val in arr:\n                if val <= target:\n                    left = max(left, val)\n                elif val >= target:\n                    right = min(right, val) if right != -1 else val\n            return [left, right]\n\n        tree_values = []\n        inorder(root, tree_values)\n        tree_values = sorted(tree_values)\n\n        return [find_closest(tree_values, q) for q in queries]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2471", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\n        def dfs(node, depth):\n            if not node:\n                return []\n            res.append((node.val, depth))\n            dfs(node.left, depth + 1)\n            dfs(node.right, depth + 1)\n\n        res = []\n        dfs(root, 0)\n        res.sort()\n        ans = 0\n        for i in range(1, len(res)):\n            if res[i][1] == res[i - 1][1]:\n                ans += 1\n        return ans\n```\n\nThis function works by first performing a depth-first search (DFS) on the tree to collect all the nodes along with their depths. The collected data is then sorted based on the depth and the value of the nodes. After sorting, the function iterates through the list and increments a counter each time it encounters a pair of nodes at the same depth but in the wrong order. This counter represents the minimum number of operations needed to sort the nodes at each level.", "extracted_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\n        def dfs(node, depth):\n            if not node:\n                return []\n            res.append((node.val, depth))\n            dfs(node.left, depth + 1)\n            dfs(node.right, depth + 1)\n\n        res = []\n        dfs(root, 0)\n        res.sort()\n        ans = 0\n        for i in range(1, len(res)):\n            if res[i][1] == res[i - 1][1]:\n                ans += 1\n        return ans\n", "difficulty": 2.0}
{"task_id": "LeetCode/2470", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom math import gcd\nfrom collections import defaultdict\n\nclass Solution:\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        lcm = [1] * n\n        lcm[0] = nums[0]\n        for i in range(1, n):\n            lcm[i] = lcm[i-1] * nums[i] // gcd(lcm[i-1], nums[i])\n\n        count = defaultdict(int)\n        count[lcm[0]] = 1\n        total = 0\n        for i in range(1, n):\n            total += count[lcm[i-1]]\n            count[lcm[i]] += 1\n\n        return total if lcm[-1] == k else total + count[k]\n```", "extracted_code": "\nfrom math import gcd\nfrom collections import defaultdict\n\nclass Solution:\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        lcm = [1] * n\n        lcm[0] = nums[0]\n        for i in range(1, n):\n            lcm[i] = lcm[i-1] * nums[i] // gcd(lcm[i-1], nums[i])\n\n        count = defaultdict(int)\n        count[lcm[0]] = 1\n        total = 0\n        for i in range(1, n):\n            total += count[lcm[i-1]]\n            count[lcm[i]] += 1\n\n        return total if lcm[-1] == k else total + count[k]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2466", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        mod = 10**9 + 7\n        dp = [[0]*(one+1) for _ in range(low+1)]\n        dp[0][0] = 1\n        for i in range(1, low+1):\n            for j in range(min(i, zero)+1):\n                dp[i][j] = (dp[i][j] + dp[i-1][j]) % mod\n                if j < one:\n                    dp[i][j] = (dp[i][j] + dp[i-1][j+1]) % mod\n        return sum(dp[i][zero] for i in range(low, high+1)) % mod\n```", "extracted_code": "\nclass Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        mod = 10**9 + 7\n        dp = [[0]*(one+1) for _ in range(low+1)]\n        dp[0][0] = 1\n        for i in range(1, low+1):\n            for j in range(min(i, zero)+1):\n                dp[i][j] = (dp[i][j] + dp[i-1][j]) % mod\n                if j < one:\n                    dp[i][j] = (dp[i][j] + dp[i-1][j+1]) % mod\n        return sum(dp[i][zero] for i in range(low, high+1)) % mod\n", "difficulty": 2.0}
{"task_id": "LeetCode/2462", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n        n = len(costs)\n        sorted_costs = sorted([(costs[i], i) for i in range(n)])\n        total_cost = 0\n        for i in range(k):\n            if i < candidates:\n                total_cost += sorted_costs[i][0]\n            else:\n                total_cost += sorted_costs[n - k + i][0]\n        return total_cost\n```", "extracted_code": "\nclass Solution:\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n        n = len(costs)\n        sorted_costs = sorted([(costs[i], i) for i in range(n)])\n        total_cost = 0\n        for i in range(k):\n            if i < candidates:\n                total_cost += sorted_costs[i][0]\n            else:\n                total_cost += sorted_costs[n - k + i][0]\n        return total_cost\n", "difficulty": 2.0}
{"task_id": "LeetCode/2461", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        if n < k:\n            return 0\n        max_sum = float('-inf')\n        for i in range(n - k + 1):\n            subarray = nums[i:i + k]\n            if len(set(subarray)) == k:\n                max_sum = max(max_sum, sum(subarray))\n        return max_sum if max_sum != float('-inf') else 0\n```", "extracted_code": "\nclass Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        if n < k:\n            return 0\n        max_sum = float('-inf')\n        for i in range(n - k + 1):\n            subarray = nums[i:i + k]\n            if len(set(subarray)) == k:\n                max_sum = max(max_sum, sum(subarray))\n        return max_sum if max_sum != float('-inf') else 0\n", "difficulty": 2.0}
{"task_id": "LeetCode/2457", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\n        n_digits = len(str(n))\n        n_sum = sum(int(digit) for digit in str(n))\n        if n_sum <= target:\n            return 0\n        else:\n            return (target+1)*(10**n_digits) - n - 1\n```", "extracted_code": "\nclass Solution:\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\n        n_digits = len(str(n))\n        n_sum = sum(int(digit) for digit in str(n))\n        if n_sum <= target:\n            return 0\n        else:\n            return (target+1)*(10**n_digits) - n - 1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2443", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sumOfNumberAndReverse(self, num: int) -> bool:\n        return num == int(str(num)[::-1]) * 2\n```", "extracted_code": "\nclass Solution:\n    def sumOfNumberAndReverse(self, num: int) -> bool:\n        return num == int(str(num)[::-1]) * 2\n", "difficulty": 2.0}
{"task_id": "LeetCode/2442", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countDistinctIntegers(self, nums: List[int]) -> int:\n        nums.extend(int(str(num)[::-1]) for num in nums)\n        return len(set(nums))\n```", "extracted_code": "\nclass Solution:\n    def countDistinctIntegers(self, nums: List[int]) -> int:\n        nums.extend(int(str(num)[::-1]) for num in nums)\n        return len(set(nums))\n", "difficulty": 2.0}
{"task_id": "LeetCode/2438", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        MOD = 10**9 + 7\n        powers = [1]\n        while powers[-1] < n:\n            powers.append(powers[-1] * 2 % MOD)\n        answers = []\n        for start, end in queries:\n            if start == 0:\n                answers.append(powers[end])\n            else:\n                answers.append(powers[end] * powers[start-1] % MOD)\n        return answers\n```", "extracted_code": "\nclass Solution:\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        MOD = 10**9 + 7\n        powers = [1]\n        while powers[-1] < n:\n            powers.append(powers[-1] * 2 % MOD)\n        answers = []\n        for start, end in queries:\n            if start == 0:\n                answers.append(powers[end])\n            else:\n                answers.append(powers[end] * powers[start-1] % MOD)\n        return answers\n", "difficulty": 2.0}
{"task_id": "LeetCode/2434", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def robotWithString(self, s: str) -> str:\n        t = ''\n        while s or t:\n            if s:\n                t += s[0]\n                s = s[1:]\n            if t:\n                t = t[:-1]\n        return t\n```", "extracted_code": "\nclass Solution:\n    def robotWithString(self, s: str) -> str:\n        t = ''\n        while s or t:\n            if s:\n                t += s[0]\n                s = s[1:]\n            if t:\n                t = t[:-1]\n        return t\n", "difficulty": 2.0}
{"task_id": "LeetCode/2429", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimizeXor(self, num1: int, num2: int) -> int:\n        x = num1\n        while True:\n            if bin(x).count('1') == bin(num2).count('1'):\n                return x\n            x += 1\n```", "extracted_code": "\nclass Solution:\n    def minimizeXor(self, num1: int, num2: int) -> int:\n        x = num1\n        while True:\n            if bin(x).count('1') == bin(num2).count('1'):\n                return x\n            x += 1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2425", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\n        xor_result = 0\n        for num1 in nums1:\n            for num2 in nums2:\n                xor_result ^= num1 ^ num2\n        return xor_result\n```", "extracted_code": "\nclass Solution:\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\n        xor_result = 0\n        for num1 in nums1:\n            for num2 in nums2:\n                xor_result ^= num1 ^ num2\n        return xor_result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2424", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass LUPrefix:\n\n    def __init__(self, n: int):\n        self.n = n\n        self.uploaded = set()\n        self.longest_prefix = 0\n\n    def upload(self, video: int) -> None:\n        self.uploaded.add(video)\n        while video - self.longest_prefix not in self.uploaded:\n            self.longest_prefix += 1\n\n    def longest(self) -> int:\n        return self.longest_prefix", "extracted_code": "\nclass LUPrefix:\n\n    def __init__(self, n: int):\n        self.n = n\n        self.uploaded = set()\n        self.longest_prefix = 0\n\n    def upload(self, video: int) -> None:\n        self.uploaded.add(video)\n        while video - self.longest_prefix not in self.uploaded:\n            self.longest_prefix += 1\n\n    def longest(self) -> int:\n        return self.longest_prefix", "difficulty": 2.0}
{"task_id": "LeetCode/2419", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_and = 0\n        longest_subarray = 0\n        for i in range(n):\n            curr_and = nums[i]\n            for j in range(i+1, n):\n                curr_and &= nums[j]\n                if curr_and > max_and:\n                    max_and = curr_and\n                    longest_subarray = j - i + 1\n                elif curr_and == max_and:\n                    longest_subarray = max(longest_subarray, j - i + 1)\n        return longest_subarray\n```\n\nThis function works by iterating over all possible subarrays of `nums` and calculating their bitwise AND. If the bitwise AND is greater than `max_and`, we update `max_and` and `longest_subarray`. If the bitwise AND is equal to `max_and`, we update `longest_subarray` if the current subarray is longer. The function finally returns the length of the longest subarray with the maximum possible bitwise AND.\n\nThe time complexity of this function is O(n^2), where n is the length of `nums`. This is because we are iterating over all possible subarrays of `nums`. The space complexity is O(1), as we are only using a constant amount of space to store `max_and` and `longest_subarray`.", "extracted_code": "\nclass Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_and = 0\n        longest_subarray = 0\n        for i in range(n):\n            curr_and = nums[i]\n            for j in range(i+1, n):\n                curr_and &= nums[j]\n                if curr_and > max_and:\n                    max_and = curr_and\n                    longest_subarray = j - i + 1\n                elif curr_and == max_and:\n                    longest_subarray = max(longest_subarray, j - i + 1)\n        return longest_subarray\n", "difficulty": 2.0}
{"task_id": "LeetCode/2415", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        def dfs(node, level):\n            if not node:\n                return\n            if level % 2:\n                node.val, node.left.val = node.left.val, node.val\n                dfs(node.left, level + 1)\n                dfs(node.right, level + 1)\n            else:\n                dfs(node.left, level + 1)\n                dfs(node.right, level + 1)\n        dfs(root, 1)\n        return root\n```", "extracted_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        def dfs(node, level):\n            if not node:\n                return\n            if level % 2:\n                node.val, node.left.val = node.left.val, node.val\n                dfs(node.left, level + 1)\n                dfs(node.right, level + 1)\n            else:\n                dfs(node.left, level + 1)\n                dfs(node.right, level + 1)\n        dfs(root, 1)\n        return root\n", "difficulty": 2.0}
{"task_id": "LeetCode/2414", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def longestContinuousSubstring(self, s: str) -> int:\n        max_length = 0\n        current_length = 1\n        prev_char = s[0]\n\n        for char in s[1:]:\n            if char == chr(ord(prev_char) + 1):\n                current_length += 1\n            else:\n                max_length = max(max_length, current_length)\n                current_length = 1\n            prev_char = char\n\n        return max(max_length, current_length)\n```", "extracted_code": "\nclass Solution:\n    def longestContinuousSubstring(self, s: str) -> int:\n        max_length = 0\n        current_length = 1\n        prev_char = s[0]\n\n        for char in s[1:]:\n            if char == chr(ord(prev_char) + 1):\n                current_length += 1\n            else:\n                max_length = max(max_length, current_length)\n                current_length = 1\n            prev_char = char\n\n        return max(max_length, current_length)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2401", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestNiceSubarray(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_length = 1\n        for i in range(n):\n            for j in range(i+1, n):\n                if (nums[i] & nums[j]) == 0:\n                    max_length = max(max_length, j-i+1)\n        return max_length\n```", "extracted_code": "\nclass Solution:\n    def longestNiceSubarray(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_length = 1\n        for i in range(n):\n            for j in range(i+1, n):\n                if (nums[i] & nums[j]) == 0:\n                    max_length = max(max_length, j-i+1)\n        return max_length\n", "difficulty": 2.0}
{"task_id": "LeetCode/2397", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\n        n = len(matrix[0])\n        cols = [0]*n\n        for row in matrix:\n            for j in range(n):\n                if row[j]:\n                    cols[j] += 1\n        select = sorted(range(n), key=lambda i: cols[i], reverse=True)\n        select = select[:numSelect]\n        rows = [0]*len(matrix)\n        for j in select:\n            for i in range(len(matrix)):\n                if matrix[i][j]:\n                    rows[i] = 1\n        return sum(rows)\n```\n\nThis function works by first counting the number of ones in each column and storing it in the `cols` list. Then, it sorts the indices of the columns based on the count in descending order. It then selects the first `numSelect` columns from this sorted list. For each of these selected columns, it iterates through the rows and sets the corresponding index in the `rows` list to 1 if the cell in the matrix is 1. Finally, it returns the sum of the `rows` list, which represents the number of rows that are covered.", "extracted_code": "\nclass Solution:\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\n        n = len(matrix[0])\n        cols = [0]*n\n        for row in matrix:\n            for j in range(n):\n                if row[j]:\n                    cols[j] += 1\n        select = sorted(range(n), key=lambda i: cols[i], reverse=True)\n        select = select[:numSelect]\n        rows = [0]*len(matrix)\n        for j in select:\n            for i in range(len(matrix)):\n                if matrix[i][j]:\n                    rows[i] = 1\n        return sum(rows)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2396", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isStrictlyPalindromic(self, n: int) -> bool:\n        for b in range(2, n):\n            s = self.int_to_base(n, b)\n            if s != s[::-1]:\n                return False\n        return True\n\n    def int_to_base(self, n: int, b: int) -> str:\n        if n == 0:\n            return '0'\n        digits = []\n        while n:\n            digits.append(str(n % b))\n            n //= b\n        return ''.join(digits[::-1])\n```\n\nThis solution works by converting the input number `n` to every base `b` between `2` and `n - 2` (inclusive). The `int_to_base` helper function is used to convert the number to a given base and return the string representation. If the string representation is not the same when reversed, the number is not strictly palindromic and `False` is returned. If all string representations are palindromic, the function returns `True`.", "extracted_code": "\nclass Solution:\n    def isStrictlyPalindromic(self, n: int) -> bool:\n        for b in range(2, n):\n            s = self.int_to_base(n, b)\n            if s != s[::-1]:\n                return False\n        return True\n\n    def int_to_base(self, n: int, b: int) -> str:\n        if n == 0:\n            return '0'\n        digits = []\n        while n:\n            digits.append(str(n % b))\n            n //= b\n        return ''.join(digits[::-1])\n", "difficulty": 2.0}
{"task_id": "LeetCode/2390", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def removeStars(self, s: str) -> str:\n        while '*' in s:\n            star_index = s.index('*')\n            s = s[:star_index] + s[star_index+1:]\n            if star_index > 0:\n                s = s[:star_index-1] + s[star_index:]\n        return s\n```", "extracted_code": "\nclass Solution:\n    def removeStars(self, s: str) -> str:\n        while '*' in s:\n            star_index = s.index('*')\n            s = s[:star_index] + s[star_index+1:]\n            if star_index > 0:\n                s = s[:star_index-1] + s[star_index:]\n        return s\n", "difficulty": 2.0}
{"task_id": "LeetCode/2385", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import deque\n\nclass Solution:\n    def amountOfTime(self, root: TreeNode, start: int) -> int:\n        queue = deque([(root, 0)])\n        infected = set()\n        minutes = 0\n\n        while queue:\n            node, time = queue.popleft()\n            if node.val not in infected:\n                infected.add(node.val)\n                minutes = time\n                if node.left:\n                    queue.append((node.left, time + 1))\n                if node.right:\n                    queue.append((node.right, time + 1))\n\n        return minutes\n```\n\nThis solution uses a breadth-first search (BFS) to traverse the tree. It uses a queue to store the nodes and their corresponding time of infection. The time of infection for a node is the time it takes for the infection to reach the node from the starting node.\n\nThe algorithm starts at the root node and adds it to the queue. Then it enters a while loop that continues until the queue is empty. In each iteration of the loop, it removes a node from the queue and checks if it has been infected. If not, it infects the node, updates the time of infection, and adds its children to the queue.\n\nThe algorithm stops when all nodes have been infected, and it returns the time of infection for the last node to be infected.", "extracted_code": "\nfrom collections import deque\n\nclass Solution:\n    def amountOfTime(self, root: TreeNode, start: int) -> int:\n        queue = deque([(root, 0)])\n        infected = set()\n        minutes = 0\n\n        while queue:\n            node, time = queue.popleft()\n            if node.val not in infected:\n                infected.add(node.val)\n                minutes = time\n                if node.left:\n                    queue.append((node.left, time + 1))\n                if node.right:\n                    queue.append((node.right, time + 1))\n\n        return minutes\n", "difficulty": 2.0}
{"task_id": "LeetCode/2368", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\n\nclass Solution:\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        dist = [0] * n\n        visited = [False] * n\n        heap = [0]\n        while heap:\n            node = heappop(heap)\n            if visited[node]:\n                continue\n            visited[node] = True\n            for nei in graph[node]:\n                if not visited[nei]:\n                    heappush(heap, nei)\n                    dist[nei] = dist[node] + 1\n        ans = len(visited) - len(restricted)\n        for node in restricted:\n            if not visited[node]:\n                ans += 1\n        return ans\n```", "extracted_code": "\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\n\nclass Solution:\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        dist = [0] * n\n        visited = [False] * n\n        heap = [0]\n        while heap:\n            node = heappop(heap)\n            if visited[node]:\n                continue\n            visited[node] = True\n            for nei in graph[node]:\n                if not visited[nei]:\n                    heappush(heap, nei)\n                    dist[nei] = dist[node] + 1\n        ans = len(visited) - len(restricted)\n        for node in restricted:\n            if not visited[node]:\n                ans += 1\n        return ans\n", "difficulty": 2.0}
{"task_id": "LeetCode/2365", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import Counter\nimport heapq\n\nclass Solution:\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\n        task_counts = list(Counter(tasks).values())\n        task_counts.sort(reverse=True)\n        time = 0\n        while task_counts:\n            i = 0\n            while i < len(task_counts):\n                if task_counts[i] > 0:\n                    task_counts[i] -= 1\n                    time += 1\n                    if task_counts[i] > 0:\n                        heapq.heappush(task_counts, -task_counts.pop(i))\n                        break\n                else:\n                    i += 1\n            else:\n                break\n        return time\n```\n\nThis function works by first counting the occurrences of each task type and then sorting the counts in descending order. It then enters a loop where it repeatedly takes the task with the most occurrences, decrement its count, and increment the time. If the task still has more occurrences, it is pushed back to the heap. The loop continues until all tasks have been completed. The time finally represents the minimum number of days needed to complete all tasks.", "extracted_code": "\nfrom collections import Counter\nimport heapq\n\nclass Solution:\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\n        task_counts = list(Counter(tasks).values())\n        task_counts.sort(reverse=True)\n        time = 0\n        while task_counts:\n            i = 0\n            while i < len(task_counts):\n                if task_counts[i] > 0:\n                    task_counts[i] -= 1\n                    time += 1\n                    if task_counts[i] > 0:\n                        heapq.heappush(task_counts, -task_counts.pop(i))\n                        break\n                else:\n                    i += 1\n            else:\n                break\n        return time\n", "difficulty": 2.0}
{"task_id": "LeetCode/2359", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        n = len(edges)\n        dist1, dist2 = [0] * n, [0] * n\n        stack1, stack2 = [node1], [node2]\n        \n        while stack1:\n            node = stack1.pop()\n            if node != -1:\n                dist1[node] = dist1[edges[node]] + 1\n                stack1.append(edges[node])\n        \n        while stack2:\n            node = stack2.pop()\n            if node != -1:\n                dist2[node] = dist2[edges[node]] + 1\n                stack2.append(edges[node])\n        \n        min_dist = float('inf')\n        min_node = -1\n        for i in range(n):\n            if edges[i] != -1 and max(dist1[i], dist2[i]) < min_dist:\n                min_dist = max(dist1[i], dist2[i])\n                min_node = i\n        \n        return min_node\n```", "extracted_code": "\nclass Solution:\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        n = len(edges)\n        dist1, dist2 = [0] * n, [0] * n\n        stack1, stack2 = [node1], [node2]\n        \n        while stack1:\n            node = stack1.pop()\n            if node != -1:\n                dist1[node] = dist1[edges[node]] + 1\n                stack1.append(edges[node])\n        \n        while stack2:\n            node = stack2.pop()\n            if node != -1:\n                dist2[node] = dist2[edges[node]] + 1\n                stack2.append(edges[node])\n        \n        min_dist = float('inf')\n        min_node = -1\n        for i in range(n):\n            if edges[i] != -1 and max(dist1[i], dist2[i]) < min_dist:\n                min_dist = max(dist1[i], dist2[i])\n                min_node = i\n        \n        return min_node\n", "difficulty": 2.0}
{"task_id": "LeetCode/2353", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\n\nclass FoodRatings:\n\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\n        self.foods = foods\n        self.cuisines = cuisines\n        self.ratings = ratings\n        self.cuisine_dict = {}\n        for i in range(len(foods)):\n            if cuisines[i] not in self.cuisine_dict:\n                self.cuisine_dict[cuisines[i]] = [(foods[i], ratings[i])]\n            else:\n                self.cuisine_dict[cuisines[i]].append((foods[i], ratings[i]))\n\n    def changeRating(self, food: str, newRating: int) -> None:\n        index = self.foods.index(food)\n        self.ratings[index] = newRating\n        for i in range(len(self.cuisines)):\n            if self.foods[i] == food:\n                self.cuisine_dict[self.cuisines[i]][i] = (self.foods[i], self.ratings[i])\n                break\n\n    def highestRated(self, cuisine: str) -> str:\n        cuisine_list = sorted(self.cuisine_dict[cuisine], key=lambda x: (-x[1], x[0]))\n        return cuisine_list[0][0]", "extracted_code": "\nfrom typing import List\n\nclass FoodRatings:\n\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\n        self.foods = foods\n        self.cuisines = cuisines\n        self.ratings = ratings\n        self.cuisine_dict = {}\n        for i in range(len(foods)):\n            if cuisines[i] not in self.cuisine_dict:\n                self.cuisine_dict[cuisines[i]] = [(foods[i], ratings[i])]\n            else:\n                self.cuisine_dict[cuisines[i]].append((foods[i], ratings[i]))\n\n    def changeRating(self, food: str, newRating: int) -> None:\n        index = self.foods.index(food)\n        self.ratings[index] = newRating\n        for i in range(len(self.cuisines)):\n            if self.foods[i] == food:\n                self.cuisine_dict[self.cuisines[i]][i] = (self.foods[i], self.ratings[i])\n                break\n\n    def highestRated(self, cuisine: str) -> str:\n        cuisine_list = sorted(self.cuisine_dict[cuisine], key=lambda x: (-x[1], x[0]))\n        return cuisine_list[0][0]", "difficulty": 2.0}
{"task_id": "LeetCode/2349", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass NumberContainers:\n\n    def __init__(self):\n        self.index_dict = {}\n        self.number_dict = {}\n\n    def change(self, index: int, number: int) -> None:\n        if number not in self.number_dict:\n            self.number_dict[number] = []\n        self.number_dict[number].append(index)\n        self.index_dict[index] = number\n\n    def find(self, number: int) -> int:\n        if number not in self.number_dict or not self.number_dict[number]:\n            return -1\n        return min(self.number_dict[number])", "extracted_code": "\nclass NumberContainers:\n\n    def __init__(self):\n        self.index_dict = {}\n        self.number_dict = {}\n\n    def change(self, index: int, number: int) -> None:\n        if number not in self.number_dict:\n            self.number_dict[number] = []\n        self.number_dict[number].append(index)\n        self.index_dict[index] = number\n\n    def find(self, number: int) -> int:\n        if number not in self.number_dict or not self.number_dict[number]:\n            return -1\n        return min(self.number_dict[number])", "difficulty": 2.0}
{"task_id": "LeetCode/2343", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\n        result = []\n        for k, trim in queries:\n            trimmed = [num[-trim:] for num in nums]\n            trimmed_sorted = sorted(trimmed)\n            result.append(trimmed_sorted.index(trimmed[k-1]))\n        return result\n```\n\nThis function works by iterating over each query. For each query, it first creates a new list `trimmed` by trimming each number in `nums` to its rightmost `trim` digits. It then sorts this list of trimmed numbers and finds the index of the `k-th` smallest trimmed number in the sorted list. This index is then appended to the result list. The function finally returns the result list.", "extracted_code": "\nclass Solution:\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\n        result = []\n        for k, trim in queries:\n            trimmed = [num[-trim:] for num in nums]\n            trimmed_sorted = sorted(trimmed)\n            result.append(trimmed_sorted.index(trimmed[k-1]))\n        return result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2342", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        digit_sums = defaultdict(list)\n        for i, num in enumerate(nums):\n            digit_sum = sum(int(digit) for digit in str(num))\n            digit_sums[digit_sum].append(num)\n        max_sum = -1\n        for nums_with_same_digit_sum in digit_sums.values():\n            max_sum = max(max_sum, max(nums_with_same_digit_sum) + min(nums_with_same_digit_sum))\n        return max_sum\n```\n\nThis function works by first creating a dictionary `digit_sums` where the keys are the sum of digits of the numbers in `nums` and the values are lists of numbers that have the same sum of digits. Then, it iterates over the values in `digit_sums` and for each list, it calculates the maximum possible sum by adding the maximum and minimum numbers in the list. Finally, it returns the maximum sum obtained over all lists in `digit_sums`. If `nums` is empty or no two numbers have the same sum of digits, it returns -1.", "extracted_code": "\nclass Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        digit_sums = defaultdict(list)\n        for i, num in enumerate(nums):\n            digit_sum = sum(int(digit) for digit in str(num))\n            digit_sums[digit_sum].append(num)\n        max_sum = -1\n        for nums_with_same_digit_sum in digit_sums.values():\n            max_sum = max(max_sum, max(nums_with_same_digit_sum) + min(nums_with_same_digit_sum))\n        return max_sum\n", "difficulty": 2.0}
{"task_id": "LeetCode/2333", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\n        n = len(nums1)\n        diffs = [(a - b) ** 2 for a, b in zip(nums1, nums2)]\n        diffs.sort()\n\n        total = sum(diffs)\n        for i in range(min(k1, k2)):\n            total -= 2 * diffs[i]\n\n        return total\n```", "extracted_code": "\nclass Solution:\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\n        n = len(nums1)\n        diffs = [(a - b) ** 2 for a, b in zip(nums1, nums2)]\n        diffs.sort()\n\n        total = sum(diffs)\n        for i in range(min(k1, k2)):\n            total -= 2 * diffs[i]\n\n        return total\n", "difficulty": 2.0}
{"task_id": "LeetCode/2320", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countHousePlacements(self, n: int) -> int:\n        MOD = 10**9 + 7\n        dp = [0] * (n + 1)\n        dp[0], dp[1] = 1, 2\n        for i in range(2, n + 1):\n            dp[i] = (dp[i - 1] + dp[i - 2] * (i - 1)) % MOD\n        return dp[n] * 2 - dp[n - 1]\n```\n\nThis function uses dynamic programming to solve the problem. The dp array stores the number of ways to place houses for each number of plots. The base cases are dp[0] = 1 (no plots, so only one arrangement) and dp[1] = 2 (one plot, so two arrangements - with a house or without a house). For each plot from 2 to n, the number of ways to place houses is the sum of the number of ways to place houses for the previous plot (i.e., dp[i - 1]) and the product of the number of ways to place houses for the (i - 2)th plot and (i - 1) (i.e., dp[i - 2] * (i - 1)), since we can place a house on the i-th plot if there is no house on the (i - 1)th plot. The result is then multiplied by 2, because for each arrangement of houses on one side of the street, we can also place houses on the other side of the street. However, if there is a house on the (n - 1)th plot on one side of the street, we cannot place a house on the n-th plot on the other side of the street, so we subtract dp[n - 1] from the final result. The result is then returned modulo 10**9 + 7 to fit within the integer range.", "extracted_code": "\nclass Solution:\n    def countHousePlacements(self, n: int) -> int:\n        MOD = 10**9 + 7\n        dp = [0] * (n + 1)\n        dp[0], dp[1] = 1, 2\n        for i in range(2, n + 1):\n            dp[i] = (dp[i - 1] + dp[i - 2] * (i - 1)) % MOD\n        return dp[n] * 2 - dp[n - 1]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2317", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumXOR(self, nums: List[int]) -> int:\n        nums = [num & 0xFFFF for num in nums]\n        trie = {}\n        for num in nums:\n            node = trie\n            for bit in range(15, -1, -1):\n                curr_bit = (num >> bit) & 1\n                if curr_bit not in node:\n                    node[curr_bit] = {}\n                node = node[curr_bit]\n                if 1 - curr_bit not in node:\n                    node[1 - curr_bit] = {}\n        best = 0\n        for num in nums:\n            node = trie\n            curr_max = 0\n            for bit in range(15, -1, -1):\n                curr_bit = (num >> bit) & 1\n                if 1 - curr_bit in node:\n                    curr_max |= (1 << bit)\n                    node = node[1 - curr_bit]\n                else:\n                    node = node[curr_bit]\n            best = max(best, curr_max)\n        return best\n```", "extracted_code": "\nclass Solution:\n    def maximumXOR(self, nums: List[int]) -> int:\n        nums = [num & 0xFFFF for num in nums]\n        trie = {}\n        for num in nums:\n            node = trie\n            for bit in range(15, -1, -1):\n                curr_bit = (num >> bit) & 1\n                if curr_bit not in node:\n                    node[curr_bit] = {}\n                node = node[curr_bit]\n                if 1 - curr_bit not in node:\n                    node[1 - curr_bit] = {}\n        best = 0\n        for num in nums:\n            node = trie\n            curr_max = 0\n            for bit in range(15, -1, -1):\n                curr_bit = (num >> bit) & 1\n                if 1 - curr_bit in node:\n                    curr_max |= (1 << bit)\n                    node = node[1 - curr_bit]\n                else:\n                    node = node[curr_bit]\n            best = max(best, curr_max)\n        return best\n", "difficulty": 2.0}
{"task_id": "LeetCode/2294", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\n\nclass Solution:\n    def partitionArray(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        n = len(nums)\n        i = 0\n        count = 1\n        while i < n - 1:\n            j = i + 1\n            while j < n and nums[j] - nums[i] <= k:\n                j += 1\n            i = j\n            count += 1\n        return count\n```\n\nThis function first sorts the input array. Then it iterates through the sorted array, and for each element, it finds the longest subsequence starting from this element whose maximum value minus the minimum value is at most `k`. It increments the count of subsequences each time it finds a new subsequence. Finally, it returns the count of subsequences.\n\nThe time complexity of this function is O(n log n) due to the sorting step, where n is the length of the input array. The space complexity is O(1) as it only uses a constant amount of space.", "extracted_code": "\nfrom typing import List\n\nclass Solution:\n    def partitionArray(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        n = len(nums)\n        i = 0\n        count = 1\n        while i < n - 1:\n            j = i + 1\n            while j < n and nums[j] - nums[i] <= k:\n                j += 1\n            i = j\n            count += 1\n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2284", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\n        word_counts = {}\n        for sender, message in zip(senders, messages):\n            word_counts[sender] = word_counts.get(sender, 0) + len(message.split())\n        max_count = max(word_counts.values())\n        max_senders = [sender for sender, count in word_counts.items() if count == max_count]\n        return min(max_senders)\n```", "extracted_code": "\nclass Solution:\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\n        word_counts = {}\n        for sender, message in zip(senders, messages):\n            word_counts[sender] = word_counts.get(sender, 0) + len(message.split())\n        max_count = max(word_counts.values())\n        max_senders = [sender for sender, count in word_counts.items() if count == max_count]\n        return min(max_senders)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2279", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\n        n = len(capacity)\n        remaining_capacity = [capacity[i] - rocks[i] for i in range(n)]\n        remaining_capacity.sort(reverse=True)\n        count = 0\n        for i in range(n):\n            if additionalRocks >= remaining_capacity[i]:\n                additionalRocks -= remaining_capacity[i]\n                count += 1\n            else:\n                break\n        if additionalRocks > 0:\n            count += additionalRocks // capacity[i]\n        return count\n```", "extracted_code": "\nclass Solution:\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\n        n = len(capacity)\n        remaining_capacity = [capacity[i] - rocks[i] for i in range(n)]\n        remaining_capacity.sort(reverse=True)\n        count = 0\n        for i in range(n):\n            if additionalRocks >= remaining_capacity[i]:\n                additionalRocks -= remaining_capacity[i]\n                count += 1\n            else:\n                break\n        if additionalRocks > 0:\n            count += additionalRocks // capacity[i]\n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2806", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n        roundedAmount = round(purchaseAmount / 10) * 10\n        return 100 - roundedAmount\n```", "extracted_code": "\nclass Solution:\n    def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n        roundedAmount = round(purchaseAmount / 10) * 10\n        return 100 - roundedAmount\n", "difficulty": 1.0}
{"task_id": "LeetCode/2788", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:\n        result = []\n        for word in words:\n            result.extend(word.split(separator))\n        return [item for item in result if item]\n```", "extracted_code": "\nclass Solution:\n    def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:\n        result = []\n        for word in words:\n            result.extend(word.split(separator))\n        return [item for item in result if item]\n", "difficulty": 1.0}
{"task_id": "LeetCode/2784", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isGood(self, nums: List[int]) -> bool:\n        n = len(nums)\n        max_num = max(nums)\n        if n != max_num:\n            return False\n        count = [0] * (n + 1)\n        for num in nums:\n            count[num] += 1\n        if any(x % 2 != 0 for x in count[:-1]):\n            return False\n        if count[-1] < 2:\n            return False\n        return True\n```", "extracted_code": "\nclass Solution:\n    def isGood(self, nums: List[int]) -> bool:\n        n = len(nums)\n        max_num = max(nums)\n        if n != max_num:\n            return False\n        count = [0] * (n + 1)\n        for num in nums:\n            count[num] += 1\n        if any(x % 2 != 0 for x in count[:-1]):\n            return False\n        if count[-1] < 2:\n            return False\n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/2744", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\n        word_set = set(words)\n        return sum(word_set.count(word) // 2 for word in word_set)\n```", "extracted_code": "\nclass Solution:\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\n        word_set = set(words)\n        return sum(word_set.count(word) // 2 for word in word_set)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2729", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isFascinating(self, n: int) -> bool:\n        # Concatenate the numbers n, 2 * n, and 3 * n\n        concatenated = str(n) + str(2 * n) + str(3 * n)\n        \n        # Check if the concatenated number contains all digits from 1 to 9 exactly once and does not contain any 0's\n        return sorted(concatenated) == '123456789'\n```", "extracted_code": "\nclass Solution:\n    def isFascinating(self, n: int) -> bool:\n        # Concatenate the numbers n, 2 * n, and 3 * n\n        concatenated = str(n) + str(2 * n) + str(3 * n)\n        \n        # Check if the concatenated number contains all digits from 1 to 9 exactly once and does not contain any 0's\n        return sorted(concatenated) == '123456789'\n", "difficulty": 1.0}
{"task_id": "LeetCode/2716", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimizedStringLength(self, s: str) -> int:\n        stack = []\n        for c in s:\n            if not stack or stack[-1] != c:\n                stack.append(c)\n            else:\n                stack.pop()\n        return len(stack)\n```\n\nThis function works by iterating over the string `s` and maintaining a stack of characters. If the current character `c` is not equal to the top of the stack, it is pushed onto the stack. If it is equal to the top of the stack, the top character is popped from the stack. This effectively removes pairs of identical consecutive characters from the string. The length of the stack after processing the entire string is the length of the minimized string.", "extracted_code": "\nclass Solution:\n    def minimizedStringLength(self, s: str) -> int:\n        stack = []\n        for c in s:\n            if not stack or stack[-1] != c:\n                stack.append(c)\n            else:\n                stack.pop()\n        return len(stack)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2697", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        n = len(s)\n        for i in range(n//2):\n            if s[i] != s[n-i-1]:\n                if ord(s[i]) > ord(s[n-i-1]):\n                    s = s[:i] + s[n-i-1] + s[i+1:]\n                else:\n                    s = s[:i] + s[i] + s[i+1:n-i-1] + s[i] + s[n-i:]\n                break\n        return s\n```\n\nThis function works by iterating over the first half of the string and comparing each character with its corresponding character from the end of the string. If the characters are not equal, it replaces the character in the first half with the smaller of the two characters, and then appends the larger character to the end of the first half. This ensures that the resulting string is a palindrome and is lexicographically smallest.", "extracted_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        n = len(s)\n        for i in range(n//2):\n            if s[i] != s[n-i-1]:\n                if ord(s[i]) > ord(s[n-i-1]):\n                    s = s[:i] + s[n-i-1] + s[i+1:]\n                else:\n                    s = s[:i] + s[i] + s[i+1:n-i-1] + s[i] + s[n-i:]\n                break\n        return s\n", "difficulty": 1.0}
{"task_id": "LeetCode/2670", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        prefix_counts = [0] * (n + 1)\n        suffix_counts = [0] * (n + 1)\n        for i in range(n):\n            prefix_counts[i + 1] = prefix_counts[i] + (nums[i] not in nums[:i])\n            suffix_counts[n - i - 1] = suffix_counts[n - i] + (nums[n - i - 1] not in nums[i + 1:])\n        return [prefix_counts[i] - suffix_counts[i] for i in range(n)]\n```", "extracted_code": "\nclass Solution:\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        prefix_counts = [0] * (n + 1)\n        suffix_counts = [0] * (n + 1)\n        for i in range(n):\n            prefix_counts[i + 1] = prefix_counts[i] + (nums[i] not in nums[:i])\n            suffix_counts[n - i - 1] = suffix_counts[n - i] + (nums[n - i - 1] not in nums[i + 1:])\n        return [prefix_counts[i] - suffix_counts[i] for i in range(n)]\n", "difficulty": 1.0}
{"task_id": "LeetCode/2652", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sumOfMultiples(self, n: int) -> int:\n        return sum(i for i in range(1, n+1) if i % 3 == 0 or i % 5 == 0 or i % 7 == 0)\n```", "extracted_code": "\nclass Solution:\n    def sumOfMultiples(self, n: int) -> int:\n        return sum(i for i in range(1, n+1) if i % 3 == 0 or i % 5 == 0 or i % 7 == 0)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2651", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\n        return (arrivalTime + delayedTime) % 24 or 24\n```", "extracted_code": "\nclass Solution:\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\n        return (arrivalTime + delayedTime) % 24 or 24\n", "difficulty": 1.0}
{"task_id": "LeetCode/2591", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distMoney(self, money: int, children: int) -> int:\n        if money < children:\n            return -1\n        if money == children:\n            return children\n        if money == children * 8:\n            return children\n        if money == children * 9:\n            return 0\n        if money == children * 10 - 2:\n            return 1\n        if money == children * 10 - 6:\n            return 2\n        return -1\n```", "extracted_code": "\nclass Solution:\n    def distMoney(self, money: int, children: int) -> int:\n        if money < children:\n            return -1\n        if money == children:\n            return children\n        if money == children * 8:\n            return children\n        if money == children * 9:\n            return 0\n        if money == children * 10 - 2:\n            return 1\n        if money == children * 10 - 6:\n            return 2\n        return -1\n", "difficulty": 1.0}
{"task_id": "LeetCode/2570", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\n        nums1_dict = {id: val for id, val in nums1}\n        nums2_dict = {id: val for id, val in nums2}\n        all_ids = set(nums1_dict.keys()).union(nums2_dict.keys())\n        result = [[id, nums1_dict.get(id, 0) + nums2_dict.get(id, 0)] for id in sorted(all_ids)]\n        return result\n```", "extracted_code": "\nclass Solution:\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\n        nums1_dict = {id: val for id, val in nums1}\n        nums2_dict = {id: val for id, val in nums2}\n        all_ids = set(nums1_dict.keys()).union(nums2_dict.keys())\n        result = [[id, nums1_dict.get(id, 0) + nums2_dict.get(id, 0)] for id in sorted(all_ids)]\n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/2481", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfCuts(self, n: int) -> int:\n        return n - 1\n```", "extracted_code": "\nclass Solution:\n    def numberOfCuts(self, n: int) -> int:\n        return n - 1\n", "difficulty": 1.0}
{"task_id": "LeetCode/2455", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        even_divisible_by_3 = [num for num in nums if num % 2 == 0 and num % 3 == 0]\n        if not even_divisible_by_3:\n            return 0\n        return sum(even_divisible_by_3) // len(even_divisible_by_3)\n```", "extracted_code": "\nclass Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        even_divisible_by_3 = [num for num in nums if num % 2 == 0 and num % 3 == 0]\n        if not even_divisible_by_3:\n            return 0\n        return sum(even_divisible_by_3) // len(even_divisible_by_3)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2432", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\n        times = [0] * n\n        for log in logs:\n            times[log[0]] += log[1]\n        max_time = max(times)\n        min_id = times.index(max_time)\n        return min_id\n```", "extracted_code": "\nclass Solution:\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\n        times = [0] * n\n        for log in logs:\n            times[log[0]] += log[1]\n        max_time = max(times)\n        min_id = times.index(max_time)\n        return min_id\n", "difficulty": 1.0}
{"task_id": "LeetCode/2427", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def commonFactors(self, a: int, b: int) -> int:\n        if a > b:\n            a, b = b, a\n        common_factors = 0\n        for i in range(1, a+1):\n            if a % i == 0 and b % i == 0:\n                common_factors += 1\n        return common_factors\n```", "extracted_code": "\nclass Solution:\n    def commonFactors(self, a: int, b: int) -> int:\n        if a > b:\n            a, b = b, a\n        common_factors = 0\n        for i in range(1, a+1):\n            if a % i == 0 and b % i == 0:\n                common_factors += 1\n        return common_factors\n", "difficulty": 1.0}
{"task_id": "LeetCode/2413", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def smallestEvenMultiple(self, n: int) -> int:\n        return n * 2\n```", "extracted_code": "\nclass Solution:\n    def smallestEvenMultiple(self, n: int) -> int:\n        return n * 2\n", "difficulty": 1.0}
{"task_id": "LeetCode/2409", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\n        month_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        a_arrive, a_leave = map(int, arriveAlice.split('-'))\n        b_arrive, b_leave = map(int, arriveBob.split('-'))\n        b_leave += 1\n        if a_arrive < b_arrive:\n            a_arrive = b_arrive\n        else:\n            b_arrive = a_arrive\n        if a_leave > b_leave:\n            a_leave = b_leave\n        else:\n            b_leave = a_leave\n        return max(0, (b_leave - a_arrive) * month_days[a_arrive - 1] - (a_arrive - b_arrive) * month_days[b_arrive - 1] + min(month_days[a_arrive - 1] - a_arrive + 1, month_days[b_arrive - 1] - b_arrive + 1))\n```", "extracted_code": "\nclass Solution:\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\n        month_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        a_arrive, a_leave = map(int, arriveAlice.split('-'))\n        b_arrive, b_leave = map(int, arriveBob.split('-'))\n        b_leave += 1\n        if a_arrive < b_arrive:\n            a_arrive = b_arrive\n        else:\n            b_arrive = a_arrive\n        if a_leave > b_leave:\n            a_leave = b_leave\n        else:\n            b_leave = a_leave\n        return max(0, (b_leave - a_arrive) * month_days[a_arrive - 1] - (a_arrive - b_arrive) * month_days[b_arrive - 1] + min(month_days[a_arrive - 1] - a_arrive + 1, month_days[b_arrive - 1] - b_arrive + 1))\n", "difficulty": 1.0}
{"task_id": "LeetCode/2399", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\n        letter_positions = {}\n        for i, letter in enumerate(s):\n            if letter in letter_positions:\n                if i - letter_positions[letter] - 1 != distance[ord(letter) - ord('a')]:\n                    return False\n            else:\n                letter_positions[letter] = i\n        return True\n```", "extracted_code": "\nclass Solution:\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\n        letter_positions = {}\n        for i, letter in enumerate(s):\n            if letter in letter_positions:\n                if i - letter_positions[letter] - 1 != distance[ord(letter) - ord('a')]:\n                    return False\n            else:\n                letter_positions[letter] = i\n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/2325", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def decodeMessage(self, key: str, message: str) -> str:\n        key_order = {ch: i for i, ch in enumerate(key) if ch not in key_order}\n        alphabet = 'abcdefghijklmnopqrstuvwxyz'\n        table = {alphabet[i]: alphabet[(i - key_order[ch]) % 26] for ch, i in key_order.items()}\n        return ''.join(table[ch] if ch in table else ch for ch in message)\n```", "extracted_code": "\nclass Solution:\n    def decodeMessage(self, key: str, message: str) -> str:\n        key_order = {ch: i for i, ch in enumerate(key) if ch not in key_order}\n        alphabet = 'abcdefghijklmnopqrstuvwxyz'\n        table = {alphabet[i]: alphabet[(i - key_order[ch]) % 26] for ch, i in key_order.items()}\n        return ''.join(table[ch] if ch in table else ch for ch in message)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2275", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def largestCombination(self, candidates: List[int]) -> int:\n        bit_counts = [bin(x).count('1') for x in candidates]\n        max_count = max(bit_counts)\n        return sum(x == max_count for x in bit_counts)\n```\n\nThis function works by first converting each number in the candidates list to its binary representation and counting the number of 1's (bits) in each representation. This gives us an array of bit counts for each number in the candidates list.\n\nNext, we find the maximum bit count (max_count) in this array.\n\nFinally, we return the sum of 1's for each bit count that equals max_count. This is because each 1 in this sum represents a combination of candidates where the bitwise AND is greater than 0.\n\nThis solution has a time complexity of O(n), where n is the number of candidates, because we need to iterate through the candidates list once to calculate the bit counts. The space complexity is also O(n), because we need to store the bit counts for each candidate.", "extracted_code": "\nclass Solution:\n    def largestCombination(self, candidates: List[int]) -> int:\n        bit_counts = [bin(x).count('1') for x in candidates]\n        max_count = max(bit_counts)\n        return sum(x == max_count for x in bit_counts)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2271", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\n        tiles.sort(key=lambda x: x[0])\n        max_covered = 0\n        left, right = 0, 0\n        while right < len(tiles):\n            if tiles[right][0] - carpetLen < tiles[left][1]:\n                max_covered = max(max_covered, tiles[right][1] - tiles[left][0] + 1)\n                right += 1\n            else:\n                left += 1\n        return max_covered\n```\n\nThis function works by first sorting the tiles by their leftmost position. Then, it iterates through the tiles and tries to place the carpet at the rightmost possible position such that it still covers the leftmost tile. If the carpet can be placed further to the right, it does so and updates the maximum number of covered white tiles. If the carpet cannot be placed further to the right, it moves to the next tile from the left and repeats the process. The function returns the maximum number of white tiles that can be covered by the carpet.", "extracted_code": "\nclass Solution:\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\n        tiles.sort(key=lambda x: x[0])\n        max_covered = 0\n        left, right = 0, 0\n        while right < len(tiles):\n            if tiles[right][0] - carpetLen < tiles[left][1]:\n                max_covered = max(max_covered, tiles[right][1] - tiles[left][0] + 1)\n                right += 1\n            else:\n                left += 1\n        return max_covered\n", "difficulty": 2.0}
{"task_id": "LeetCode/2270", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def waysToSplitArray(self, nums: List[int]) -> int:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        count = 0\n        for i in range(n):\n            if prefix_sum[i] >= prefix_sum[n] - prefix_sum[i + 1]:\n                count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def waysToSplitArray(self, nums: List[int]) -> int:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        count = 0\n        for i in range(n):\n            if prefix_sum[i] >= prefix_sum[n] - prefix_sum[i + 1]:\n                count += 1\n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2269", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def kBeauty(self, num: int, k: int) -> int:\n        num_str = str(num)\n        beauty_count = 0\n        for i in range(len(num_str) - k + 1):\n            substring = num_str[i:i+k]\n            if substring[0] != '0' or len(substring) == 1:\n                if num % int(substring) == 0:\n                    beauty_count += 1\n        return beauty_count\n```", "extracted_code": "\nclass Solution:\n    def kBeauty(self, num: int, k: int) -> int:\n        num_str = str(num)\n        beauty_count = 0\n        for i in range(len(num_str) - k + 1):\n            substring = num_str[i:i+k]\n            if substring[0] != '0' or len(substring) == 1:\n                if num % int(substring) == 0:\n                    beauty_count += 1\n        return beauty_count\n", "difficulty": 1.0}
{"task_id": "LeetCode/2259", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def removeDigit(self, number: str, digit: str) -> str:\n        index = number.find(digit)\n        if index == 0:\n            while index < len(number) and number[index] == digit:\n                index += 1\n            return number[:index] + number[index+1:]\n        else:\n            while index > 0 and number[index] == digit:\n                index -= 1\n            return number[:index] + number[index+1:]\n```", "extracted_code": "\nclass Solution:\n    def removeDigit(self, number: str, digit: str) -> str:\n        index = number.find(digit)\n        if index == 0:\n            while index < len(number) and number[index] == digit:\n                index += 1\n            return number[:index] + number[index+1:]\n        else:\n            while index > 0 and number[index] == digit:\n                index -= 1\n            return number[:index] + number[index+1:]\n", "difficulty": 1.0}
{"task_id": "LeetCode/2248", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def intersection(self, nums: List[List[int]]) -> List[int]:\n        intersection_set = set(nums[0])\n        for num in nums[1:]:\n            intersection_set.intersection_update(num)\n        return sorted(list(intersection_set))\n```", "extracted_code": "\nclass Solution:\n    def intersection(self, nums: List[List[int]]) -> List[int]:\n        intersection_set = set(nums[0])\n        for num in nums[1:]:\n            intersection_set.intersection_update(num)\n        return sorted(list(intersection_set))\n", "difficulty": 1.0}
{"task_id": "LeetCode/2245", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[0]*n for _ in range(m)]\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        max_zeros = 0\n\n        def dfs(x, y, dx, dy):\n            nonlocal max_zeros\n            count = 0\n            while 0 <= x < m and 0 <= y < n:\n                count += grid[x][y]\n                grid[x][y] = 0\n                x, y = x + dx, y + dy\n            max_zeros = max(max_zeros, count.bit_length() - 1)\n\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    for dx, dy in directions:\n                        dfs(i + dx, j + dy, dx, dy)\n\n        return max_zeros\n```\n\nThis solution uses depth-first search (DFS) to explore all possible cornered paths in the grid. The `dfs` function is used to traverse the path and count the product of all the numbers in the path. The `bit_length` function is used to calculate the number of trailing zeros in the product. The maximum trailing zeros is updated whenever a new maximum is found. The time complexity of this solution is O(m*n), where m and n are the dimensions of the grid.", "extracted_code": "\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[0]*n for _ in range(m)]\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        max_zeros = 0\n\n        def dfs(x, y, dx, dy):\n            nonlocal max_zeros\n            count = 0\n            while 0 <= x < m and 0 <= y < n:\n                count += grid[x][y]\n                grid[x][y] = 0\n                x, y = x + dx, y + dy\n            max_zeros = max(max_zeros, count.bit_length() - 1)\n\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    for dx, dy in directions:\n                        dfs(i + dx, j + dy, dx, dy)\n\n        return max_zeros\n", "difficulty": 2.0}
{"task_id": "LeetCode/2241", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass ATM:\n\n    def __init__(self):\n        self.banknotes = [0, 0, 0, 0, 0]\n\n    def deposit(self, banknotesCount: List[int]) -> None:\n        for i in range(5):\n            self.banknotes[i] += banknotesCount[i]\n\n    def withdraw(self, amount: int) -> List[int]:\n        notes = [0, 0, 0, 0, 0]\n        if amount > 500 * self.banknotes[4] + 200 * self.banknotes[3] + 100 * self.banknotes[2] + 50 * self.banknotes[1] + 20 * self.banknotes[0]:\n            return [-1]\n        else:\n            notes[4] = amount // 500\n            amount %= 500\n            notes[3] = amount // 200\n            amount %= 200\n            notes[2] = amount // 100\n            amount %= 100\n            notes[1] = amount // 50\n            amount %= 50\n            notes[0] = amount // 20\n            self.banknotes = [self.banknotes[i] - notes[i] for i in range(5)]\n            return notes\n```", "extracted_code": "\nclass ATM:\n\n    def __init__(self):\n        self.banknotes = [0, 0, 0, 0, 0]\n\n    def deposit(self, banknotesCount: List[int]) -> None:\n        for i in range(5):\n            self.banknotes[i] += banknotesCount[i]\n\n    def withdraw(self, amount: int) -> List[int]:\n        notes = [0, 0, 0, 0, 0]\n        if amount > 500 * self.banknotes[4] + 200 * self.banknotes[3] + 100 * self.banknotes[2] + 50 * self.banknotes[1] + 20 * self.banknotes[0]:\n            return [-1]\n        else:\n            notes[4] = amount // 500\n            amount %= 500\n            notes[3] = amount // 200\n            amount %= 200\n            notes[2] = amount // 100\n            amount %= 100\n            notes[1] = amount // 50\n            amount %= 50\n            notes[0] = amount // 20\n            self.banknotes = [self.banknotes[i] - notes[i] for i in range(5)]\n            return notes\n", "difficulty": 2.0}
{"task_id": "LeetCode/2215", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\n        set1, set2 = set(nums1), set(nums2)\n        return [[i for i in set1 if i not in set2], [i for i in set2 if i not in set1]]\n```", "extracted_code": "\nclass Solution:\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\n        set1, set2 = set(nums1), set(nums2)\n        return [[i for i in set1 if i not in set2], [i for i in set2 if i not in set1]]\n", "difficulty": 1.0}
{"task_id": "LeetCode/2206", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import Counter\n\nclass Solution:\n    def divideArray(self, nums: List[int]) -> bool:\n        n = len(nums) // 2\n        count = Counter(nums)\n        return all(x % 2 == 0 for x in count.values()) and all(x // 2 == n for x in count.values())\n```\n\nThis function works by first dividing the length of the input array by 2 to get the number of pairs required. It then creates a frequency count of all the elements in the array using the Counter class from the collections library.\n\nThe function then checks two conditions:\n\n1. All counts are even, meaning every element can be paired with another identical element.\n2. The count of each element divided by 2 equals the required number of pairs.\n\nIf both conditions are met, the function returns True, otherwise it returns False.", "extracted_code": "\nfrom collections import Counter\n\nclass Solution:\n    def divideArray(self, nums: List[int]) -> bool:\n        n = len(nums) // 2\n        count = Counter(nums)\n        return all(x % 2 == 0 for x in count.values()) and all(x // 2 == n for x in count.values())\n", "difficulty": 1.0}
{"task_id": "LeetCode/2160", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumSum(self, num: int) -> int:\n        digits = list(map(int, str(num)))\n        digits.sort()\n        new1 = int(''.join(map(str, digits[:2])))\n        new2 = int(''.join(map(str, digits[2:])))\n        return new1 + new2\n```", "extracted_code": "\nclass Solution:\n    def minimumSum(self, num: int) -> int:\n        digits = list(map(int, str(num)))\n        digits.sort()\n        new1 = int(''.join(map(str, digits[:2])))\n        new2 = int(''.join(map(str, digits[2:])))\n        return new1 + new2\n", "difficulty": 1.0}
{"task_id": "LeetCode/2148", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countElements(self, nums: List[int]) -> int:\n        nums = set(nums)\n        return sum(nums.__contains__(x - 1) and nums.__contains__(x + 1) for x in nums)\n```", "extracted_code": "\nclass Solution:\n    def countElements(self, nums: List[int]) -> int:\n        nums = set(nums)\n        return sum(nums.__contains__(x - 1) and nums.__contains__(x + 1) for x in nums)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2068", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        diff = [0]*26\n        for i in range(26):\n            diff[i] = abs(word1.count(chr(97+i)) - word2.count(chr(97+i)))\n        return all(x<=3 for x in diff)\n```", "extracted_code": "\nclass Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        diff = [0]*26\n        for i in range(26):\n            diff[i] = abs(word1.count(chr(97+i)) - word2.count(chr(97+i)))\n        return all(x<=3 for x in diff)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2053", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def kthDistinct(self, arr: List[str], k: int) -> str:\n        distinct_strings = set(arr)\n        return arr[k-1] if k <= len(distinct_strings) else \"\"\n```", "extracted_code": "\nclass Solution:\n    def kthDistinct(self, arr: List[str], k: int) -> str:\n        distinct_strings = set(arr)\n        return arr[k-1] if k <= len(distinct_strings) else \"\"\n", "difficulty": 1.0}
{"task_id": "LeetCode/2032", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\n        return list(set(nums1 + nums2 + nums3) - set(nums1) - set(nums2) - set(nums3))\n```", "extracted_code": "\nclass Solution:\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\n        return list(set(nums1 + nums2 + nums3) - set(nums1) - set(nums2) - set(nums3))\n", "difficulty": 1.0}
{"task_id": "LeetCode/2027", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumMoves(self, s: str) -> int:\n        return sum(c == 'X' for c in s) // 3\n```", "extracted_code": "\nclass Solution:\n    def minimumMoves(self, s: str) -> int:\n        return sum(c == 'X' for c in s) // 3\n", "difficulty": 1.0}
{"task_id": "LeetCode/2006", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countKDifference(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if abs(nums[i] - nums[j]) == k:\n                    count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countKDifference(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if abs(nums[i] - nums[j]) == k:\n                    count += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/1995", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n        for a in range(n):\n            for b in range(a+1, n):\n                for c in range(b+1, n):\n                    for d in range(c+1, n):\n                        if nums[a] + nums[b] + nums[c] == nums[d]:\n                            count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n        for a in range(n):\n            for b in range(a+1, n):\n                for c in range(b+1, n):\n                    for d in range(c+1, n):\n                        if nums[a] + nums[b] + nums[c] == nums[d]:\n                            count += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/1974", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minTimeToType(self, word: str) -> int:\n        # Calculate the time to move from character 'a' to character 'b'\n        move_time = {chr(97 + i): (i + 1) % 26 for i in range(26)}\n        \n        # Initialize the total time and the current character\n        total_time = 0\n        current_char = 'a'\n        \n        # Iterate through the characters in the word\n        for char in word:\n            # Calculate the time to move from the current character to the next character\n            total_time += move_time[current_char]\n            \n            # Update the current character\n            current_char = char\n            \n        # Add the time to type the last character\n        total_time += 1\n        \n        return total_time\n```", "extracted_code": "\nclass Solution:\n    def minTimeToType(self, word: str) -> int:\n        # Calculate the time to move from character 'a' to character 'b'\n        move_time = {chr(97 + i): (i + 1) % 26 for i in range(26)}\n        \n        # Initialize the total time and the current character\n        total_time = 0\n        current_char = 'a'\n        \n        # Iterate through the characters in the word\n        for char in word:\n            # Calculate the time to move from the current character to the next character\n            total_time += move_time[current_char]\n            \n            # Update the current character\n            current_char = char\n            \n        # Add the time to type the last character\n        total_time += 1\n        \n        return total_time\n", "difficulty": 1.0}
{"task_id": "LeetCode/1971", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import defaultdict\n\nclass Solution:\n    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        visited = set()\n        \n        def dfs(node):\n            if node == destination:\n                return True\n            if node in visited:\n                return False\n            visited.add(node)\n            return any(dfs(neighbour) for neighbour in graph[node])\n        \n        return dfs(source)\n```\n\nThis function first builds an adjacency list representation of the graph. Then it performs a depth-first search (DFS) from the source node to the destination node. The DFS will return True if it finds the destination node, and False otherwise. The visited set stores the nodes that have been visited during the DFS, ensuring that there are no cycles in the graph.", "extracted_code": "\nfrom collections import defaultdict\n\nclass Solution:\n    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        visited = set()\n        \n        def dfs(node):\n            if node == destination:\n                return True\n            if node in visited:\n                return False\n            visited.add(node)\n            return any(dfs(neighbour) for neighbour in graph[node])\n        \n        return dfs(source)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1925", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countTriples(self, n: int) -> int:\n        count = 0\n        for a in range(1, n+1):\n            for b in range(a, n+1):\n                c = (a**2 + b**2)**0.5\n                if c.is_integer() and c <= n:\n                    count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countTriples(self, n: int) -> int:\n        count = 0\n        for a in range(1, n+1):\n            for b in range(a, n+1):\n                c = (a**2 + b**2)**0.5\n                if c.is_integer() and c <= n:\n                    count += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/1920", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def buildArray(self, nums: List[int]) -> List[int]:\n        return [nums[nums[i]] for i in range(len(nums))]\n```", "extracted_code": "\nclass Solution:\n    def buildArray(self, nums: List[int]) -> List[int]:\n        return [nums[nums[i]] for i in range(len(nums))]\n", "difficulty": 1.0}
{"task_id": "LeetCode/1886", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:\n        for _ in range(4):\n            if mat == target:\n                return True\n            mat = list(zip(*mat[::-1]))\n        return False\n```", "extracted_code": "\nclass Solution:\n    def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:\n        for _ in range(4):\n            if mat == target:\n                return True\n            mat = list(zip(*mat[::-1]))\n        return False\n", "difficulty": 1.0}
{"task_id": "LeetCode/1880", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:\n        def str_to_num(s: str) -> int:\n            return int(''.join(str(ord(c) - ord('a')) for c in s))\n\n        return str_to_num(firstWord) + str_to_num(secondWord) == str_to_num(targetWord)\n```", "extracted_code": "\nclass Solution:\n    def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:\n        def str_to_num(s: str) -> int:\n            return int(''.join(str(ord(c) - ord('a')) for c in s))\n\n        return str_to_num(firstWord) + str_to_num(secondWord) == str_to_num(targetWord)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1854", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\n\nclass Solution:\n    def maximumPopulation(self, logs: List[List[int]]) -> int:\n        years = [0] * 101\n        for log in logs:\n            years[log[0]-1950:log[1]-1950] = [1]*(log[1]-log[0])\n        return 1950 + years.index(max(years))\n```", "extracted_code": "\nfrom typing import List\n\nclass Solution:\n    def maximumPopulation(self, logs: List[List[int]]) -> int:\n        years = [0] * 101\n        for log in logs:\n            years[log[0]-1950:log[1]-1950] = [1]*(log[1]-log[0])\n        return 1950 + years.index(max(years))\n", "difficulty": 1.0}
{"task_id": "LeetCode/1837", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sumBase(self, n: int, k: int) -> int:\n        return sum(int(digit) for digit in str(n))\n```", "extracted_code": "\nclass Solution:\n    def sumBase(self, n: int, k: int) -> int:\n        return sum(int(digit) for digit in str(n))\n", "difficulty": 1.0}
{"task_id": "LeetCode/1800", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxAscendingSum(self, nums: List[int]) -> int:\n        max_sum = 0\n        curr_sum = 0\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i-1]:\n                curr_sum += nums[i]\n            else:\n                max_sum = max(max_sum, curr_sum)\n                curr_sum = nums[i]\n        return max(max_sum, curr_sum)\n```", "extracted_code": "\nclass Solution:\n    def maxAscendingSum(self, nums: List[int]) -> int:\n        max_sum = 0\n        curr_sum = 0\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i-1]:\n                curr_sum += nums[i]\n            else:\n                max_sum = max(max_sum, curr_sum)\n                curr_sum = nums[i]\n        return max(max_sum, curr_sum)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1768", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def mergeAlternately(self, word1: str, word2: str) -> str:\n        merged = ''\n        i, j = 0, 0\n        while i < len(word1) and j < len(word2):\n            merged += word1[i] + word2[j]\n            i += 1\n            j += 1\n        if i < len(word1):\n            merged += word1[i:]\n        if j < len(word2):\n            merged += word2[j:]\n        return merged\n```", "extracted_code": "\nclass Solution:\n    def mergeAlternately(self, word1: str, word2: str) -> str:\n        merged = ''\n        i, j = 0, 0\n        while i < len(word1) and j < len(word2):\n            merged += word1[i] + word2[j]\n            i += 1\n            j += 1\n        if i < len(word1):\n            merged += word1[i:]\n        if j < len(word2):\n            merged += word2[j:]\n        return merged\n", "difficulty": 1.0}
{"task_id": "LeetCode/1758", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minOperations(self, s: str) -> int:\n        # Initialize variables\n        n = len(s)\n        zero_count = 0\n        one_count = 0\n        min_operations = 0\n\n        # Iterate through the string\n        for i in range(n):\n            # Count the number of 0s and 1s\n            if s[i] == '0':\n                zero_count += 1\n            else:\n                one_count += 1\n\n            # Update the minimum number of operations\n            min_operations += abs(zero_count - one_count)\n\n        return min_operations\n```\n\nThis function works by iterating through the string and counting the number of 0s and 1s. The minimum number of operations is updated by taking the absolute difference between the counts of 0s and 1s. This ensures that the string remains alternating at each step. The final minimum number of operations is the sum of these differences for all characters in the string.", "extracted_code": "\nclass Solution:\n    def minOperations(self, s: str) -> int:\n        # Initialize variables\n        n = len(s)\n        zero_count = 0\n        one_count = 0\n        min_operations = 0\n\n        # Iterate through the string\n        for i in range(n):\n            # Count the number of 0s and 1s\n            if s[i] == '0':\n                zero_count += 1\n            else:\n                one_count += 1\n\n            # Update the minimum number of operations\n            min_operations += abs(zero_count - one_count)\n\n        return min_operations\n", "difficulty": 1.0}
{"task_id": "LeetCode/1748", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sumOfUnique(self, nums: List[int]) -> int:\n        unique_nums = set(nums)\n        return sum(unique_num for unique_num in unique_nums if nums.count(unique_num) == 1)\n```", "extracted_code": "\nclass Solution:\n    def sumOfUnique(self, nums: List[int]) -> int:\n        unique_nums = set(nums)\n        return sum(unique_num for unique_num in unique_nums if nums.count(unique_num) == 1)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1656", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass OrderedStream:\n\n    def __init__(self, n: int):\n        self.values = [None]*n\n        self.ptr = 0\n\n    def insert(self, idKey: int, value: str) -> List[str]:\n        self.values[idKey-1] = value\n        result = []\n        while self.ptr < len(self.values) and self.values[self.ptr] is not None:\n            result.append(self.values[self.ptr])\n            self.ptr += 1\n        return result\n```", "extracted_code": "\nclass OrderedStream:\n\n    def __init__(self, n: int):\n        self.values = [None]*n\n        self.ptr = 0\n\n    def insert(self, idKey: int, value: str) -> List[str]:\n        self.values[idKey-1] = value\n        result = []\n        while self.ptr < len(self.values) and self.values[self.ptr] is not None:\n            result.append(self.values[self.ptr])\n            self.ptr += 1\n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/1640", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:\n        pieces_dict = {pieces[i][0]: pieces[i] for i in range(len(pieces))}\n        for i in range(len(arr)):\n            if arr[i] not in pieces_dict:\n                return False\n            if pieces_dict[arr[i]][0] != arr[i]:\n                return False\n            pieces_dict[arr[i]].pop(0)\n            if not pieces_dict[arr[i]]:\n                del pieces_dict[arr[i]]\n        return True\n```", "extracted_code": "\nclass Solution:\n    def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:\n        pieces_dict = {pieces[i][0]: pieces[i] for i in range(len(pieces))}\n        for i in range(len(arr)):\n            if arr[i] not in pieces_dict:\n                return False\n            if pieces_dict[arr[i]][0] != arr[i]:\n                return False\n            pieces_dict[arr[i]].pop(0)\n            if not pieces_dict[arr[i]]:\n                del pieces_dict[arr[i]]\n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/1619", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def trimMean(self, arr: List[int]) -> float:\n        arr.sort()\n        n = len(arr)\n        five_percent = int(n * 0.05)\n        return sum(arr[five_percent:-five_percent]) / (n - 2 * five_percent)\n```", "extracted_code": "\nclass Solution:\n    def trimMean(self, arr: List[int]) -> float:\n        arr.sort()\n        n = len(arr)\n        five_percent = int(n * 0.05)\n        return sum(arr[five_percent:-five_percent]) / (n - 2 * five_percent)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1614", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maxDepth(self, s: str) -> int:\n        depth = 0\n        max_depth = 0\n        for char in s:\n            if char == '(':\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif char == ')':\n                depth -= 1\n        return max_depth\n```", "extracted_code": "\nclass Solution:\n    def maxDepth(self, s: str) -> int:\n        depth = 0\n        max_depth = 0\n        for char in s:\n            if char == '(':\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif char == ')':\n                depth -= 1\n        return max_depth\n", "difficulty": 1.0}
{"task_id": "LeetCode/1582", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def numSpecial(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        rows, cols = [0]*m, [0]*n\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1:\n                    rows[i] += 1\n                    cols[j] += 1\n        return sum(mat[i][j] == 1 and rows[i] == 1 and cols[j] == 1 for i in range(m) for j in range(n))\n```", "extracted_code": "\nclass Solution:\n    def numSpecial(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        rows, cols = [0]*m, [0]*n\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1:\n                    rows[i] += 1\n                    cols[j] += 1\n        return sum(mat[i][j] == 1 and rows[i] == 1 and cols[j] == 1 for i in range(m) for j in range(n))\n", "difficulty": 1.0}
{"task_id": "LeetCode/1566", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def containsPattern(self, arr: List[int], m: int, k: int) -> bool:\n        for i in range(len(arr) - m * k + 1):\n            if all(arr[i+j] == arr[i+j+m] for j in range(m) for _ in range(k-1)):\n                return True\n        return False\n```\n\nThis function works by iterating over the array with a step size of `m * k - m`. This is because we are looking for a pattern of length `m` that is repeated `k` or more times, so we don't need to check every position in the array.\n\nInside the loop, we use a nested list comprehension to check if the pattern of length `m` is repeated `k` times. We use the `all` function to ensure that every comparison in the nested list comprehension must be true for the entire expression to be true.\n\nIf the pattern is found, the function returns `True`. If the function finishes iterating over the array without finding the pattern, it returns `False`.", "extracted_code": "\nclass Solution:\n    def containsPattern(self, arr: List[int], m: int, k: int) -> bool:\n        for i in range(len(arr) - m * k + 1):\n            if all(arr[i+j] == arr[i+j+m] for j in range(m) for _ in range(k-1)):\n                return True\n        return False\n", "difficulty": 1.0}
{"task_id": "LeetCode/1556", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def thousandSeparator(self, n: int) -> str:\n        return '{:,}'.format(n).replace(',', '.')\n```", "extracted_code": "\nclass Solution:\n    def thousandSeparator(self, n: int) -> str:\n        return '{:,}'.format(n).replace(',', '.')\n", "difficulty": 1.0}
{"task_id": "LeetCode/1534", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\n        n = len(arr)\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if abs(arr[i] - arr[j]) > a:\n                    continue\n                for k in range(j+1, n):\n                    if abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\n                        count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\n        n = len(arr)\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if abs(arr[i] - arr[j]) > a:\n                    continue\n                for k in range(j+1, n):\n                    if abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\n                        count += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/1496", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isPathCrossing(self, path: str) -> bool:\n        x, y, visited = 0, 0, set()\n        visited.add((x, y))\n        for direction in path:\n            if direction == 'N':\n                y += 1\n            elif direction == 'S':\n                y -= 1\n            elif direction == 'E':\n                x += 1\n            else:\n                x -= 1\n            if (x, y) in visited:\n                return True\n            visited.add((x, y))\n        return False\n```", "extracted_code": "\nclass Solution:\n    def isPathCrossing(self, path: str) -> bool:\n        x, y, visited = 0, 0, set()\n        visited.add((x, y))\n        for direction in path:\n            if direction == 'N':\n                y += 1\n            elif direction == 'S':\n                y -= 1\n            elif direction == 'E':\n                x += 1\n            else:\n                x -= 1\n            if (x, y) in visited:\n                return True\n            visited.add((x, y))\n        return False\n", "difficulty": 1.0}
{"task_id": "LeetCode/1486", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def xorOperation(self, n: int, start: int) -> int:\n        nums = [start + 2 * i for i in range(n)]\n        result = nums[0]\n        for num in nums[1:]:\n            result ^= num\n        return result\n```", "extracted_code": "\nclass Solution:\n    def xorOperation(self, n: int, start: int) -> int:\n        nums = [start + 2 * i for i in range(n)]\n        result = nums[0]\n        for num in nums[1:]:\n            result ^= num\n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/1464", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        nums = sorted(nums)\n        return (nums[-1]-1) * (nums[-2]-1)\n```", "extracted_code": "\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        nums = sorted(nums)\n        return (nums[-1]-1) * (nums[-2]-1)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1431", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:\n        max_candy = max(candies)\n        return [candy + extraCandies >= max_candy for candy in candies]\n```", "extracted_code": "\nclass Solution:\n    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:\n        max_candy = max(candies)\n        return [candy + extraCandies >= max_candy for candy in candies]\n", "difficulty": 1.0}
{"task_id": "LeetCode/1422", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxScore(self, s: str) -> int:\n        left_zeros = 0\n        right_ones = 0\n        max_score = 0\n        for i in range(len(s) - 1):\n            if s[i] == '0':\n                left_zeros += 1\n            else:\n                right_ones += 1\n            max_score = max(max_score, left_zeros + right_ones)\n        return max_score\n```", "extracted_code": "\nclass Solution:\n    def maxScore(self, s: str) -> int:\n        left_zeros = 0\n        right_ones = 0\n        max_score = 0\n        for i in range(len(s) - 1):\n            if s[i] == '0':\n                left_zeros += 1\n            else:\n                right_ones += 1\n            max_score = max(max_score, left_zeros + right_ones)\n        return max_score\n", "difficulty": 1.0}
{"task_id": "LeetCode/1408", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def stringMatching(self, words: List[str]) -> List[str]:\n        words.sort(key=len)\n        result = []\n        for i in range(len(words)):\n            for j in range(i+1, len(words)):\n                if words[i] in words[j]:\n                    result.append(words[i])\n                    break\n        return result\n```\n\nThis function works by first sorting the words by their length. Then, it iterates through the list of words and checks if the current word is a substring of any other word that comes after it in the sorted list. If it is, the word is added to the result list. The function finally returns the result list, which contains all the words that are substrings of another word.", "extracted_code": "\nclass Solution:\n    def stringMatching(self, words: List[str]) -> List[str]:\n        words.sort(key=len)\n        result = []\n        for i in range(len(words)):\n            for j in range(i+1, len(words)):\n                if words[i] in words[j]:\n                    result.append(words[i])\n                    break\n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/1399", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countLargestGroup(self, n: int) -> int:\n        from collections import defaultdict\n        digit_sums = defaultdict(list)\n        for i in range(1, n+1):\n            digit_sums[sum(int(digit) for digit in str(i))].append(i)\n        max_group_size = max(len(group) for group in digit_sums.values())\n        return sum(1 for group in digit_sums.values() if len(group) == max_group_size)\n```", "extracted_code": "\nclass Solution:\n    def countLargestGroup(self, n: int) -> int:\n        from collections import defaultdict\n        digit_sums = defaultdict(list)\n        for i in range(1, n+1):\n            digit_sums[sum(int(digit) for digit in str(i))].append(i)\n        max_group_size = max(len(group) for group in digit_sums.values())\n        return sum(1 for group in digit_sums.values() if len(group) == max_group_size)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1360", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nfrom datetime import datetime\n\nclass Solution:\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\n        date_format = \"%Y-%m-%d\"\n        a = datetime.strptime(date1, date_format)\n        b = datetime.strptime(date2, date_format)\n        return abs((a - b).days)\n```", "extracted_code": "\nfrom datetime import datetime\n\nclass Solution:\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\n        date_format = \"%Y-%m-%d\"\n        a = datetime.strptime(date1, date_format)\n        b = datetime.strptime(date2, date_format)\n        return abs((a - b).days)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1323", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maximum69Number (self, num: int) -> int:\n        num_str = str(num)\n        for i in range(len(num_str)):\n            if num_str[i] == '6':\n                num_str = num_str[:i] + '9' + num_str[i+1:]\n                break\n        return int(num_str)\n```", "extracted_code": "\nclass Solution:\n    def maximum69Number (self, num: int) -> int:\n        num_str = str(num)\n        for i in range(len(num_str)):\n            if num_str[i] == '6':\n                num_str = num_str[:i] + '9' + num_str[i+1:]\n                break\n        return int(num_str)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1304", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sumZero(self, n: int) -> List[int]:\n        if n % 2 == 1:\n            return [0] + list(range(1, n, 2)) + list(range(-1, -n, -2))\n        else:\n            return list(range(-n//2, 0)) + list(range(1, n//2+1))\n```", "extracted_code": "\nclass Solution:\n    def sumZero(self, n: int) -> List[int]:\n        if n % 2 == 1:\n            return [0] + list(range(1, n, 2)) + list(range(-1, -n, -2))\n        else:\n            return list(range(-n//2, 0)) + list(range(1, n//2+1))\n", "difficulty": 1.0}
{"task_id": "LeetCode/1266", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def minTimeToVisitAllPoints(self, points: List[List[int]]) -> int:\n        time = 0\n        for i in range(1, len(points)):\n            x_diff = abs(points[i][0] - points[i-1][0])\n            y_diff = abs(points[i][1] - points[i-1][1])\n            time += max(x_diff, y_diff)\n        return time\n```", "extracted_code": "\nclass Solution:\n    def minTimeToVisitAllPoints(self, points: List[List[int]]) -> int:\n        time = 0\n        for i in range(1, len(points)):\n            x_diff = abs(points[i][0] - points[i-1][0])\n            y_diff = abs(points[i][1] - points[i-1][1])\n            time += max(x_diff, y_diff)\n        return time\n", "difficulty": 1.0}
{"task_id": "LeetCode/1252", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\n        matrix = [[0]*n for _ in range(m)]\n        for r, c in indices:\n            for i in range(n):\n                matrix[r][i] += 1\n            for i in range(m):\n                matrix[i][c] += 1\n        return sum(row[i] % 2 for row in matrix for i in range(n))\n```", "extracted_code": "\nclass Solution:\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\n        matrix = [[0]*n for _ in range(m)]\n        for r, c in indices:\n            for i in range(n):\n                matrix[r][i] += 1\n            for i in range(m):\n                matrix[i][c] += 1\n        return sum(row[i] % 2 for row in matrix for i in range(n))\n", "difficulty": 1.0}
{"task_id": "LeetCode/1207", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        return len(set(arr)) == len(Counter(arr).values())\n```\n\nIn this solution, we use Python's built-in `Counter` from `collections` to count the occurrences of each number in the array. The `Counter` function returns a dictionary where the keys are the numbers in the array and the values are the counts.\n\nThen, we convert the dictionary values to a set, which removes any duplicates. If the length of the set is equal to the length of the dictionary values, it means that all counts are unique, and we return `True`. Otherwise, we return `False`.", "extracted_code": "\nclass Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        return len(set(arr)) == len(Counter(arr).values())\n", "difficulty": 1.0}
{"task_id": "LeetCode/1200", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nfrom typing import List\n\nclass Solution:\n    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:\n        arr.sort()\n        min_diff = float('inf')\n        for i in range(1, len(arr)):\n            min_diff = min(min_diff, arr[i] - arr[i-1])\n        result = [[arr[i], arr[i+1]] for i in range(len(arr)-1) if arr[i+1] - arr[i] == min_diff]\n        return result\n```\n\nThis function first sorts the input array. Then it iterates through the sorted array to find the minimum absolute difference between consecutive elements. Finally, it iterates through the sorted array again to find all pairs of elements with the minimum absolute difference and returns the result.", "extracted_code": "\nfrom typing import List\n\nclass Solution:\n    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:\n        arr.sort()\n        min_diff = float('inf')\n        for i in range(1, len(arr)):\n            min_diff = min(min_diff, arr[i] - arr[i-1])\n        result = [[arr[i], arr[i+1]] for i in range(len(arr)-1) if arr[i+1] - arr[i] == min_diff]\n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/1175", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def numPrimeArrangements(self, n: int) -> int:\n        mod = 10**9 + 7\n        def factorial(n):\n            f = [1]*(n+1)\n            for i in range(2, n+1):\n                f[i] = f[i-1]*i % mod\n            return f\n        def is_prime(n):\n            if n < 2: return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0: return False\n            return True\n        f = factorial(n)\n        primes = sum(is_prime(i) for i in range(1, n+1))\n        composites = n - primes\n        return f[primes] * f[composites] % mod\n```", "extracted_code": "\nclass Solution:\n    def numPrimeArrangements(self, n: int) -> int:\n        mod = 10**9 + 7\n        def factorial(n):\n            f = [1]*(n+1)\n            for i in range(2, n+1):\n                f[i] = f[i-1]*i % mod\n            return f\n        def is_prime(n):\n            if n < 2: return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0: return False\n            return True\n        f = factorial(n)\n        primes = sum(is_prime(i) for i in range(1, n+1))\n        composites = n - primes\n        return f[primes] * f[composites] % mod\n", "difficulty": 1.0}
{"task_id": "LeetCode/1128", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\n        dominoes_dict = {}\n        for domino in dominoes:\n            domino.sort()\n            domino_tuple = tuple(domino)\n            if domino_tuple in dominoes_dict:\n                dominoes_dict[domino_tuple] += 1\n            else:\n                dominoes_dict[domino_tuple] = 1\n        return sum(n * (n - 1) // 2 for n in dominoes_dict.values())\n```\n\nThis function works by first creating a dictionary `dominoes_dict` where the keys are the sorted dominoes and the values are the counts of each domino. The sorted dominoes ensures that each equivalent pair of dominoes will have the same key. Then, it computes the number of pairs for each count in the dictionary and sums them up. The formula `n * (n - 1) // 2` is used to calculate the number of pairs for a given count `n`.", "extracted_code": "\nclass Solution:\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\n        dominoes_dict = {}\n        for domino in dominoes:\n            domino.sort()\n            domino_tuple = tuple(domino)\n            if domino_tuple in dominoes_dict:\n                dominoes_dict[domino_tuple] += 1\n            else:\n                dominoes_dict[domino_tuple] = 1\n        return sum(n * (n - 1) // 2 for n in dominoes_dict.values())\n", "difficulty": 1.0}
{"task_id": "LeetCode/1108", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def defangIPaddr(self, address: str) -> str:\n        return address.replace('.', '[.]')\n```", "extracted_code": "\nclass Solution:\n    def defangIPaddr(self, address: str) -> str:\n        return address.replace('.', '[.]')\n", "difficulty": 1.0}
{"task_id": "LeetCode/1103", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\n        result = [0] * num_people\n        current_candy = 0\n        while candies > 0:\n            for i in range(num_people):\n                give_candy = min(candies, current_candy + i + 1)\n                result[i] += give_candy\n                candies -= give_candy\n                if candies == 0:\n                    break\n            current_candy += num_people\n        return result\n```", "extracted_code": "\nclass Solution:\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\n        result = [0] * num_people\n        current_candy = 0\n        while candies > 0:\n            for i in range(num_people):\n                give_candy = min(candies, current_candy + i + 1)\n                result[i] += give_candy\n                candies -= give_candy\n                if candies == 0:\n                    break\n            current_candy += num_people\n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/1071", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def gcdOfStrings(self, str1: str, str2: str) -> str:\n        if len(str1) < len(str2):\n            str1, str2 = str2, str1\n        if not str1.startswith(str2):\n            return \"\"\n        if str1 == str2:\n            return str2\n        return self.gcdOfStrings(str1[len(str2):], str2)\n```", "extracted_code": "\nclass Solution:\n    def gcdOfStrings(self, str1: str, str2: str) -> str:\n        if len(str1) < len(str2):\n            str1, str2 = str2, str1\n        if not str1.startswith(str2):\n            return \"\"\n        if str1 == str2:\n            return str2\n        return self.gcdOfStrings(str1[len(str2):], str2)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1025", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def divisorGame(self, n: int) -> bool:\n        dp = [False] * (n + 1)\n        for i in range(2, n + 1):\n            for j in range(1, i):\n                if i % j == 0 and not dp[i - j]:\n                    dp[i] = True\n                    break\n        return dp[n]\n```", "extracted_code": "\nclass Solution:\n    def divisorGame(self, n: int) -> bool:\n        dp = [False] * (n + 1)\n        for i in range(2, n + 1):\n            for j in range(1, i):\n                if i % j == 0 and not dp[i - j]:\n                    dp[i] = True\n                    break\n        return dp[n]\n", "difficulty": 1.0}
{"task_id": "LeetCode/1009", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def bitwiseComplement(self, n: int) -> int:\n        return (2**len(bin(n)[2:])-1) ^ n\n```", "extracted_code": "\nclass Solution:\n    def bitwiseComplement(self, n: int) -> int:\n        return (2**len(bin(n)[2:])-1) ^ n\n", "difficulty": 1.0}
{"task_id": "LeetCode/993", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isCousins(self, root: Optional[TreeNode], x: int, y: int) -> bool:\n        def dfs(node, parent, depth):\n            if node:\n                if node.val == x or node.val == y:\n                    if node.val == x: \n                        nonlocal x_parent, x_depth\n                        x_parent, x_depth = parent, depth\n                    else: \n                        nonlocal y_parent, y_depth\n                        y_parent, y_depth = parent, depth\n                else:\n                    dfs(node.left, node.val, depth + 1)\n                    dfs(node.right, node.val, depth + 1)\n\n        x_parent = y_parent = x_depth = y_depth = None\n        dfs(root, None, 0)\n        return x_depth == y_depth and x_parent != y_parent\n```", "extracted_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isCousins(self, root: Optional[TreeNode], x: int, y: int) -> bool:\n        def dfs(node, parent, depth):\n            if node:\n                if node.val == x or node.val == y:\n                    if node.val == x: \n                        nonlocal x_parent, x_depth\n                        x_parent, x_depth = parent, depth\n                    else: \n                        nonlocal y_parent, y_depth\n                        y_parent, y_depth = parent, depth\n                else:\n                    dfs(node.left, node.val, depth + 1)\n                    dfs(node.right, node.val, depth + 1)\n\n        x_parent = y_parent = x_depth = y_depth = None\n        dfs(root, None, 0)\n        return x_depth == y_depth and x_parent != y_parent\n", "difficulty": 1.0}
{"task_id": "LeetCode/965", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isUnivalTree(self, root: Optional[TreeNode]) -> bool:\n        if not root:\n            return True\n        if root.left and root.val != root.left.val:\n            return False\n        if root.right and root.val != root.right.val:\n            return False\n        return self.isUnivalTree(root.left) and self.isUnivalTree(root.right)\n```", "extracted_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isUnivalTree(self, root: Optional[TreeNode]) -> bool:\n        if not root:\n            return True\n        if root.left and root.val != root.left.val:\n            return False\n        if root.right and root.val != root.right.val:\n            return False\n        return self.isUnivalTree(root.left) and self.isUnivalTree(root.right)\n", "difficulty": 1.0}
{"task_id": "LeetCode/953", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        order_dict = {char: i for i, char in enumerate(order)}\n        for i in range(len(words) - 1):\n            word1 = words[i]\n            word2 = words[i + 1]\n            for j in range(min(len(word1), len(word2))):\n                if word1[j] != word2[j]:\n                    if order_dict[word1[j]] > order_dict[word2[j]]:\n                        return False\n                    break\n            else:\n                if len(word1) > len(word2):\n                    return False\n        return True\n```\n\nThis function works by first creating a dictionary `order_dict` that maps each character to its position in the given order. Then, it iterates over the list of words, comparing each pair of consecutive words. For each pair of words, it compares their characters one by one. If it finds two different characters, it checks if the first character is greater than the second one according to the order_dict. If it is, it returns False, because the words are not sorted according to the given order. If it doesn't find any different characters but one word is longer than the other, it also returns False, because the shorter word should come first in a lexicographically sorted list. If it manages to compare all characters of all words without returning False, it returns True, because the words are sorted according to the given order.", "extracted_code": "\nclass Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        order_dict = {char: i for i, char in enumerate(order)}\n        for i in range(len(words) - 1):\n            word1 = words[i]\n            word2 = words[i + 1]\n            for j in range(min(len(word1), len(word2))):\n                if word1[j] != word2[j]:\n                    if order_dict[word1[j]] > order_dict[word2[j]]:\n                        return False\n                    break\n            else:\n                if len(word1) > len(word2):\n                    return False\n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/944", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        num_cols = len(strs[0])\n        num_rows = len(strs)\n        num_delete = 0\n\n        for col in range(num_cols):\n            for row in range(num_rows - 1):\n                if strs[row][col] > strs[row + 1][col]:\n                    num_delete += 1\n                    break\n\n        return num_delete\n```", "extracted_code": "\nclass Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        num_cols = len(strs[0])\n        num_rows = len(strs)\n        num_delete = 0\n\n        for col in range(num_cols):\n            for row in range(num_rows - 1):\n                if strs[row][col] > strs[row + 1][col]:\n                    num_delete += 1\n                    break\n\n        return num_delete\n", "difficulty": 1.0}
{"task_id": "LeetCode/933", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass RecentCounter:\n\n    def __init__(self):\n        self.requests = []\n\n    def ping(self, t: int) -> int:\n        self.requests.append(t)\n        while self.requests[0] < t - 3000:\n            self.requests.pop(0)\n        return len(self.requests)", "extracted_code": "\nclass RecentCounter:\n\n    def __init__(self):\n        self.requests = []\n\n    def ping(self, t: int) -> int:\n        self.requests.append(t)\n        while self.requests[0] < t - 3000:\n            self.requests.pop(0)\n        return len(self.requests)", "difficulty": 1.0}
{"task_id": "LeetCode/914", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import Counter\n\nclass Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        count = Counter(deck)\n        return reduce(lambda x, y: x * y // math.gcd(x, y), count.values()) >= 2\n```\n\nThis function works by first counting the occurrence of each number in the deck using the Counter class from the collections library. Then, it computes the greatest common divisor (gcd) of all the counts using the reduce function from the functools library. If the gcd is greater than or equal to 2, it means that it's possible to partition the deck into groups of size x, where x > 1, and all cards in one group have the same integer written on them. Otherwise, it returns false.", "extracted_code": "\nfrom collections import Counter\n\nclass Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        count = Counter(deck)\n        return reduce(lambda x, y: x * y // math.gcd(x, y), count.values()) >= 2\n", "difficulty": 1.0}
{"task_id": "LeetCode/892", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def surfaceArea(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        area = 0\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] > 0:\n                    area += 2  # for each cube, there are two faces on the top and bottom\n                if i > 0:\n                    area += max(grid[i][j] - grid[i - 1][j], 0)\n                if j > 0:\n                    area += max(grid[i][j] - grid[i][j - 1], 0)\n        return area\n```\n\nThis function works by iterating through each cell in the grid, and for each cell, it checks the cells to its left and top to calculate the surface area. If the current cell has a height greater than the cell to its left or top, then the difference in height represents a new face that is exposed, so we add that difference to the total surface area. The area of the top and bottom faces of each cube is always added, as these faces are always exposed.", "extracted_code": "\nclass Solution:\n    def surfaceArea(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        area = 0\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] > 0:\n                    area += 2  # for each cube, there are two faces on the top and bottom\n                if i > 0:\n                    area += max(grid[i][j] - grid[i - 1][j], 0)\n                if j > 0:\n                    area += max(grid[i][j] - grid[i][j - 1], 0)\n        return area\n", "difficulty": 1.0}
{"task_id": "LeetCode/888", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\n        alice_sum = sum(aliceSizes)\n        bob_sum = sum(bobSizes)\n        delta = (bob_sum - alice_sum) // 2\n\n        alice_set = set(aliceSizes)\n        for bob_candy in bobSizes:\n            if bob_candy - delta in alice_set:\n                return [bob_candy - delta, bob_candy]\n```\n\nThis function works by first calculating the difference in total candies between Alice and Bob. This difference is then divided by 2 to find the difference in the size of the candy boxes that Alice and Bob need to exchange.\n\nThe function then converts Alice's list of candy box sizes into a set for faster lookups. It then iterates over Bob's list of candy box sizes, checking if the size of the box that Alice needs to exchange is present in Alice's set of box sizes.\n\nIf a suitable box size is found, the function returns a list containing the sizes of the boxes that Alice and Bob need to exchange.", "extracted_code": "\nclass Solution:\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\n        alice_sum = sum(aliceSizes)\n        bob_sum = sum(bobSizes)\n        delta = (bob_sum - alice_sum) // 2\n\n        alice_set = set(aliceSizes)\n        for bob_candy in bobSizes:\n            if bob_candy - delta in alice_set:\n                return [bob_candy - delta, bob_candy]\n", "difficulty": 1.0}
{"task_id": "LeetCode/867", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\n        return [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n```", "extracted_code": "\nclass Solution:\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\n        return [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n", "difficulty": 1.0}
{"task_id": "LeetCode/844", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def backspaceCompare(self, s: str, t: str) -> bool:\n        i, j = len(s) - 1, len(t) - 1\n        backspace_s, backspace_t = 0, 0\n\n        while i >= 0 or j >= 0:\n            while i >= 0:\n                if s[i] == '#':\n                    backspace_s += 1\n                    i -= 1\n                elif backspace_s > 0:\n                    backspace_s -= 1\n                    i -= 1\n                else:\n                    break\n\n            while j >= 0:\n                if t[j] == '#':\n                    backspace_t += 1\n                    j -= 1\n                elif backspace_t > 0:\n                    backspace_t -= 1\n                    j -= 1\n                else:\n                    break\n\n            if i >= 0 and j >= 0 and s[i] != t[j]:\n                return False\n\n            if (i >= 0) != (j >= 0):\n                return False\n\n            i -= 1\n            j -= 1\n\n        return True\n```", "extracted_code": "\nclass Solution:\n    def backspaceCompare(self, s: str, t: str) -> bool:\n        i, j = len(s) - 1, len(t) - 1\n        backspace_s, backspace_t = 0, 0\n\n        while i >= 0 or j >= 0:\n            while i >= 0:\n                if s[i] == '#':\n                    backspace_s += 1\n                    i -= 1\n                elif backspace_s > 0:\n                    backspace_s -= 1\n                    i -= 1\n                else:\n                    break\n\n            while j >= 0:\n                if t[j] == '#':\n                    backspace_t += 1\n                    j -= 1\n                elif backspace_t > 0:\n                    backspace_t -= 1\n                    j -= 1\n                else:\n                    break\n\n            if i >= 0 and j >= 0 and s[i] != t[j]:\n                return False\n\n            if (i >= 0) != (j >= 0):\n                return False\n\n            i -= 1\n            j -= 1\n\n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/830", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def largeGroupPositions(self, s: str) -> List[List[int]]:\n        res = []\n        i = 0\n        for j in range(len(s)):\n            if j == len(s) - 1 or s[j] != s[j+1]:\n                if j - i + 1 >= 3:\n                    res.append([i, j])\n                i = j + 1\n        return res\n```", "extracted_code": "\nclass Solution:\n    def largeGroupPositions(self, s: str) -> List[List[int]]:\n        res = []\n        i = 0\n        for j in range(len(s)):\n            if j == len(s) - 1 or s[j] != s[j+1]:\n                if j - i + 1 >= 3:\n                    res.append([i, j])\n                i = j + 1\n        return res\n", "difficulty": 1.0}
{"task_id": "LeetCode/804", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\n        morse_words = set()\n        for word in words:\n            morse_word = \"\"\n            for c in word:\n                morse_word += morse[ord(c) - ord('a')]\n            morse_words.add(morse_word)\n        return len(morse_words)\n```", "extracted_code": "\nclass Solution:\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\n        morse_words = set()\n        for word in words:\n            morse_word = \"\"\n            for c in word:\n                morse_word += morse[ord(c) - ord('a')]\n            morse_words.add(morse_word)\n        return len(morse_words)\n", "difficulty": 1.0}
{"task_id": "LeetCode/762", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countPrimeSetBits(self, left: int, right: int) -> int:\n        def is_prime(n):\n            if n < 2:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        return sum(is_prime(bin(i).count('1')) for i in range(left, right + 1))\n```\n\nThis function works by first defining a helper function `is_prime` that checks if a given number is prime. Then, it uses a generator expression to count the number of prime set bits for every number in the inclusive range `[left, right]`. The `bin` function is used to convert each number to its binary representation, and `str.count` is used to count the number of set bits. Finally, the `sum` function is used to count the total number of prime set bit numbers in the range.", "extracted_code": "\nclass Solution:\n    def countPrimeSetBits(self, left: int, right: int) -> int:\n        def is_prime(n):\n            if n < 2:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        return sum(is_prime(bin(i).count('1')) for i in range(left, right + 1))\n", "difficulty": 1.0}
{"task_id": "LeetCode/728", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n        result = []\n        for num in range(left, right + 1):\n            if all(int(digit) != 0 and num % int(digit) == 0 for digit in str(num)):\n                result.append(num)\n        return result\n```", "extracted_code": "\nclass Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n        result = []\n        for num in range(left, right + 1):\n            if all(int(digit) != 0 and num % int(digit) == 0 for digit in str(num)):\n                result.append(num)\n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/706", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass MyHashMap:\n\n    def __init__(self):\n        self.map = []\n\n    def put(self, key: int, value: int) -> None:\n        for i in range(len(self.map)):\n            if self.map[i][0] == key:\n                self.map[i][1] = value\n                return\n        self.map.append([key, value])\n\n    def get(self, key: int) -> int:\n        for i in range(len(self.map)):\n            if self.map[i][0] == key:\n                return self.map[i][1]\n        return -1\n\n    def remove(self, key: int) -> None:\n        for i in range(len(self.map)):\n            if self.map[i][0] == key:\n                del self.map[i]\n                return\n```", "extracted_code": "\nclass MyHashMap:\n\n    def __init__(self):\n        self.map = []\n\n    def put(self, key: int, value: int) -> None:\n        for i in range(len(self.map)):\n            if self.map[i][0] == key:\n                self.map[i][1] = value\n                return\n        self.map.append([key, value])\n\n    def get(self, key: int) -> int:\n        for i in range(len(self.map)):\n            if self.map[i][0] == key:\n                return self.map[i][1]\n        return -1\n\n    def remove(self, key: int) -> None:\n        for i in range(len(self.map)):\n            if self.map[i][0] == key:\n                del self.map[i]\n                return\n", "difficulty": 1.0}
{"task_id": "LeetCode/704", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n```", "extracted_code": "\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n", "difficulty": 1.0}
{"task_id": "LeetCode/682", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        record = []\n        for op in operations:\n            if op == '+':\n                record.append(record[-1] + record[-2])\n            elif op == 'C':\n                record.pop()\n            elif op == 'D':\n                record.append(record[-1] * 2)\n            else:\n                record.append(int(op))\n        return sum(record)\n```", "extracted_code": "\nclass Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        record = []\n        for op in operations:\n            if op == '+':\n                record.append(record[-1] + record[-2])\n            elif op == 'C':\n                record.pop()\n            elif op == 'D':\n                record.append(record[-1] * 2)\n            else:\n                record.append(int(op))\n        return sum(record)\n", "difficulty": 1.0}
{"task_id": "LeetCode/680", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def validPalindrome(self, s: str) -> bool:\n        left, right = 0, len(s) - 1\n        while left < right:\n            if s[left] != s[right]:\n                return s[left + 1:right + 1] == s[left + 1:right + 1][::-1] or s[left:right] == s[left:right][::-1]\n            left += 1\n            right -= 1\n        return True\n```", "extracted_code": "\nclass Solution:\n    def validPalindrome(self, s: str) -> bool:\n        left, right = 0, len(s) - 1\n        while left < right:\n            if s[left] != s[right]:\n                return s[left + 1:right + 1] == s[left + 1:right + 1][::-1] or s[left:right] == s[left:right][::-1]\n            left += 1\n            right -= 1\n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/674", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        max_length = 1\n        current_length = 1\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                current_length += 1\n            else:\n                max_length = max(max_length, current_length)\n                current_length = 1\n        return max(max_length, current_length)\n```", "extracted_code": "\nclass Solution:\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        max_length = 1\n        current_length = 1\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                current_length += 1\n            else:\n                max_length = max(max_length, current_length)\n                current_length = 1\n        return max(max_length, current_length)\n", "difficulty": 1.0}
{"task_id": "LeetCode/671", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return -1\n        left = root.left.val if root.left else float('inf')\n        right = root.right.val if root.right else float('inf')\n        if left == root.val:\n            left = self.findSecondMinimumValue(root.left)\n        if right == root.val:\n            right = self.findSecondMinimumValue(root.right)\n        if left == float('inf') or right == float('inf'):\n            return max(left, right)\n        else:\n            return min(left, right)\n```", "extracted_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return -1\n        left = root.left.val if root.left else float('inf')\n        right = root.right.val if root.right else float('inf')\n        if left == root.val:\n            left = self.findSecondMinimumValue(root.left)\n        if right == root.val:\n            right = self.findSecondMinimumValue(root.right)\n        if left == float('inf') or right == float('inf'):\n            return max(left, right)\n        else:\n            return min(left, right)\n", "difficulty": 1.0}
{"task_id": "LeetCode/645", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findErrorNums(self, nums: List[int]) -> List[int]:\n        duplicate = -1\n        missing = -1\n        for num in nums:\n            if nums[abs(num) - 1] < 0:\n                duplicate = abs(num)\n            else:\n                nums[abs(num) - 1] *= -1\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                missing = i + 1\n        return [duplicate, missing]\n```", "extracted_code": "\nclass Solution:\n    def findErrorNums(self, nums: List[int]) -> List[int]:\n        duplicate = -1\n        missing = -1\n        for num in nums:\n            if nums[abs(num) - 1] < 0:\n                duplicate = abs(num)\n            else:\n                nums[abs(num) - 1] *= -1\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                missing = i + 1\n        return [duplicate, missing]\n", "difficulty": 1.0}
{"task_id": "LeetCode/617", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:\n        if not root1: \n            return root2\n        if not root2: \n            return root1\n        \n        root1.val += root2.val\n        root1.left = self.mergeTrees(root1.left, root2.left)\n        root1.right = self.mergeTrees(root1.right, root2.right)\n        \n        return root1\n```", "extracted_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:\n        if not root1: \n            return root2\n        if not root2: \n            return root1\n        \n        root1.val += root2.val\n        root1.left = self.mergeTrees(root1.left, root2.left)\n        root1.right = self.mergeTrees(root1.right, root2.right)\n        \n        return root1\n", "difficulty": 1.0}
{"task_id": "LeetCode/599", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        index_sum = float('inf')\n        common_strings = []\n        map1 = {v: i for i, v in enumerate(list1)}\n        for j, v in enumerate(list2):\n            if v in map1:\n                if map1[v] + j < index_sum:\n                    index_sum = map1[v] + j\n                    common_strings = [v]\n                elif map1[v] + j == index_sum:\n                    common_strings.append(v)\n        return common_strings\n```\n\nThis function works by first creating a dictionary `map1` that maps each string in `list1` to its index. Then, it iterates over each string `v` in `list2` with its index `j`. If `v` is in `map1`, it checks if the sum of its index in `list1` and `j` is less than `index_sum`. If it is, it updates `index_sum` to this new value and sets `common_strings` to a list containing just `v`. If the sum is equal to `index_sum`, it appends `v` to `common_strings`. Finally, it returns `common_strings`.", "extracted_code": "\nclass Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        index_sum = float('inf')\n        common_strings = []\n        map1 = {v: i for i, v in enumerate(list1)}\n        for j, v in enumerate(list2):\n            if v in map1:\n                if map1[v] + j < index_sum:\n                    index_sum = map1[v] + j\n                    common_strings = [v]\n                elif map1[v] + j == index_sum:\n                    common_strings.append(v)\n        return common_strings\n", "difficulty": 1.0}
{"task_id": "LeetCode/572", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        if not root:\n            return False\n        if self.isSame(root, subRoot):\n            return True\n        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)\n\n    def isSame(self, root, subRoot):\n        if not root and not subRoot:\n            return True\n        if not root or not subRoot:\n            return False\n        if root.val != subRoot.val:\n            return False\n        return self.isSame(root.left, subRoot.left) and self.isSame(root.right, subRoot.right)\n```", "extracted_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        if not root:\n            return False\n        if self.isSame(root, subRoot):\n            return True\n        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)\n\n    def isSame(self, root, subRoot):\n        if not root and not subRoot:\n            return True\n        if not root or not subRoot:\n            return False\n        if root.val != subRoot.val:\n            return False\n        return self.isSame(root.left, subRoot.left) and self.isSame(root.right, subRoot.right)\n", "difficulty": 1.0}
{"task_id": "LeetCode/551", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def checkRecord(self, s: str) -> bool:\n        if s.count('A') >= 2:\n            return False\n        for i in range(len(s) - 2):\n            if s[i:i+3].count('L') >= 3:\n                return False\n        return True\n```", "extracted_code": "\nclass Solution:\n    def checkRecord(self, s: str) -> bool:\n        if s.count('A') >= 2:\n            return False\n        for i in range(len(s) - 2):\n            if s[i:i+3].count('L') >= 3:\n                return False\n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/509", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def fib(self, n: int) -> int:\n        if n <= 1:\n            return n\n        a, b = 0, 1\n        for _ in range(n - 1):\n            a, b = b, a + b\n        return b\n```", "extracted_code": "\nclass Solution:\n    def fib(self, n: int) -> int:\n        if n <= 1:\n            return n\n        a, b = 0, 1\n        for _ in range(n - 1):\n            a, b = b, a + b\n        return b\n", "difficulty": 1.0}
